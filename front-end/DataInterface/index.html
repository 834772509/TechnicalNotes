<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数据结构与算法 | 杉-技术笔记</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/TechnicalNotes/img/LOGO.ico">
    <meta name="description" content="记录工作和学习过程中的笔记">
    
    <link rel="preload" href="/TechnicalNotes/assets/css/0.styles.a649f350.css" as="style"><link rel="preload" href="/TechnicalNotes/assets/js/app.403c09eb.js" as="script"><link rel="preload" href="/TechnicalNotes/assets/js/3.de768786.js" as="script"><link rel="preload" href="/TechnicalNotes/assets/js/2.0ff0e0af.js" as="script"><link rel="preload" href="/TechnicalNotes/assets/js/13.7842862e.js" as="script"><link rel="prefetch" href="/TechnicalNotes/assets/js/10.cd8d0b02.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/100.d40eab6c.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/101.0c0f9cec.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/102.7b24bcb6.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/103.32415862.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/104.76128a4b.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/105.32a58842.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/106.5cff38aa.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/107.3e306b76.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/108.d6c963cc.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/109.e6b5e5ec.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/11.5b0a37bf.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/110.a2701e83.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/111.92d434f7.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/112.e5f66c51.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/113.4938f6e0.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/114.c4ce16e9.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/115.6e0b070f.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/116.eae29c2a.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/117.0a85c4af.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/118.0954561e.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/119.3c31b140.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/12.bf58f438.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/120.bc0a9e5f.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/121.7b677fee.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/122.f0d475b9.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/123.f155f063.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/124.3b3f662c.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/125.aff78ffa.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/126.cf048a9f.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/127.f8d04191.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/128.ea316c9c.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/129.ebe031aa.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/130.67027926.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/131.4c2d83ce.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/132.78e92cac.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/133.46f39123.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/134.917de34c.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/135.1a73b656.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/136.6a37e5f3.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/137.18a99d57.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/138.89004c46.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/139.6bb0290b.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/14.883f8d81.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/140.c409a126.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/15.d5b2b6fe.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/16.cb6c6fe5.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/17.af5c5bd9.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/18.b9595e9a.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/19.760784f9.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/20.92f76292.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/21.0e27b07f.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/22.bd39b9f6.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/23.bab8e88f.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/24.ac88976e.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/25.828943ae.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/26.5fa1f671.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/27.0e43a1f2.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/28.70af786c.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/29.06e1b3fd.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/30.82b38d58.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/31.5b98e640.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/32.996ea25f.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/33.34bff53d.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/34.a0277424.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/35.30b289a2.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/36.140bf430.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/37.48ddda34.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/38.f95c2d20.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/39.1dc8aa20.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/4.bdbec019.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/40.c1ac30ef.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/41.024ca6be.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/42.82911591.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/43.1eb0ddae.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/44.389d410c.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/45.cf62b16a.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/46.af9db920.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/47.1268088f.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/48.84016bf6.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/49.a3e09c19.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/5.3f9f4083.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/50.04edb325.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/51.e7ef6ced.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/52.bee03ff5.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/53.c030ba72.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/54.55ab470f.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/55.5daecb5f.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/56.831ae79e.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/57.b6dab452.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/58.204950a1.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/59.e5ba6640.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/6.1c35e102.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/60.7f5188b7.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/61.51ebe81e.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/62.bad69981.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/63.a4184e9d.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/64.8b7751d6.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/65.df07a5bd.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/66.952954e1.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/67.f5220078.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/68.0c4bab54.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/69.835eae40.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/7.c8dbdb3f.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/70.bb19f8a9.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/71.3e75f181.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/72.9f20879f.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/73.adae5848.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/74.8804d933.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/75.d4bd1ebb.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/76.be509071.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/77.088ed0e0.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/78.6fec8ee0.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/79.fb3bfc3a.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/8.d9d4169f.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/80.b51c8f18.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/81.78066b85.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/82.035fbfe7.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/83.71fb4555.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/84.c81bea90.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/85.9cabf024.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/86.ccc4f606.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/87.8412152e.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/88.4d3459c8.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/89.44c041c0.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/9.9865799d.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/90.5bc1c8d4.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/91.b9a72908.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/92.910d91ce.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/93.5c50dcd3.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/94.46a34e49.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/95.b455b9cf.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/96.80a9a783.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/97.db0f3990.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/98.e92c36dc.js"><link rel="prefetch" href="/TechnicalNotes/assets/js/99.67ab1ed7.js">
    <link rel="stylesheet" href="/TechnicalNotes/assets/css/0.styles.a649f350.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><main><main slot="sidebar-top"><!----></main> <div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/TechnicalNotes/" class="home-link router-link-active"><!----> <span class="site-name">杉-技术笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/TechnicalNotes/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Web 开发
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/HTML5/" class="nav-link">
  HTML5
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/CSS3/" class="nav-link">
  CSS3
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/JavaScript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/TypeScript/" class="nav-link">
  TypeScript
</a></li></ul></li><li class="dropdown-item"><h4>
          前端框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/Vue2/" class="nav-link">
  Vue2
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/Vue3/" class="nav-link">
  Vue3
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/React/" class="nav-link">
  React
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/Webpack/" class="nav-link">
  Webpack
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/Vite/" class="nav-link">
  Vite
</a></li></ul></li><li class="dropdown-item"><h4>
          移动端开发
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/Andorid/" class="nav-link">
  Andorid
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/Flutter/" class="nav-link">
  Flutter
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/WechatApplet/" class="nav-link">
  微信小程序
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/Electron/" class="nav-link">
  Electron
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/DataInterface/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  数据结构与算法
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><span class="title">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Java
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Java/" class="nav-link">
  Java 基础
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Java/JavaWeb/" class="nav-link">
  JavaWeb
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Java/Mybatis/" class="nav-link">
  Mybatis
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Java/Spring/" class="nav-link">
  Spring
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Java/SpringMVC/" class="nav-link">
  SpringMVC
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Java/SpringBoot/" class="nav-link">
  SpringBoot
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Java/JVM/" class="nav-link">
  JVM
</a></li></ul></li><li class="dropdown-item"><h4>
          Rust
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Rust/" class="nav-link">
  Rust
</a></li></ul></li><li class="dropdown-item"><h4>
          Node.js
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Node.js/" class="nav-link">
  Node.js
</a></li></ul></li><li class="dropdown-item"><h4>
          Python
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Python/" class="nav-link">
  Python 基础
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Python/Flask/" class="nav-link">
  Flask
</a></li></ul></li><li class="dropdown-item"><h4>
          数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/DataBase/MySQL/" class="nav-link">
  MySQL
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/DataBase/Redis/" class="nav-link">
  Redis
</a></li></ul></li><li class="dropdown-item"><h4>
          PHP
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/PHP/" class="nav-link">
  PHP 基础
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/PHP/ThinkPHP/" class="nav-link">
  ThinkPHP
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/TechnicalNotes/Other/Photoshop/" class="nav-link">
  Photoshop
</a></li><li class="dropdown-item"><!----> <a href="/TechnicalNotes/Other/Git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/TechnicalNotes/Other/WinPE/" class="nav-link">
  WinPE
</a></li><li class="dropdown-item"><!----> <a href="/TechnicalNotes/Other/Minecraft/" class="nav-link">
  Minecraft
</a></li><li class="dropdown-item"><!----> <a href="/TechnicalNotes/Other/FL Studio/" class="nav-link">
  FL Studio
</a></li></ul></div></div><div class="nav-item"><a href="https://firpe.cn/about" target="_blank" rel="noopener noreferrer" class="nav-link external">
  关于
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://firpe.cn/donate" target="_blank" rel="noopener noreferrer" class="nav-link external">
  投食 
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/TechnicalNotes/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Web 开发
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/HTML5/" class="nav-link">
  HTML5
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/CSS3/" class="nav-link">
  CSS3
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/JavaScript/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/TypeScript/" class="nav-link">
  TypeScript
</a></li></ul></li><li class="dropdown-item"><h4>
          前端框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/Vue2/" class="nav-link">
  Vue2
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/Vue3/" class="nav-link">
  Vue3
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/React/" class="nav-link">
  React
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/Webpack/" class="nav-link">
  Webpack
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/Vite/" class="nav-link">
  Vite
</a></li></ul></li><li class="dropdown-item"><h4>
          移动端开发
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/Andorid/" class="nav-link">
  Andorid
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/Flutter/" class="nav-link">
  Flutter
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/WechatApplet/" class="nav-link">
  微信小程序
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/Electron/" class="nav-link">
  Electron
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/front-end/DataInterface/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  数据结构与算法
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><span class="title">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Java
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Java/" class="nav-link">
  Java 基础
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Java/JavaWeb/" class="nav-link">
  JavaWeb
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Java/Mybatis/" class="nav-link">
  Mybatis
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Java/Spring/" class="nav-link">
  Spring
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Java/SpringMVC/" class="nav-link">
  SpringMVC
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Java/SpringBoot/" class="nav-link">
  SpringBoot
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Java/JVM/" class="nav-link">
  JVM
</a></li></ul></li><li class="dropdown-item"><h4>
          Rust
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Rust/" class="nav-link">
  Rust
</a></li></ul></li><li class="dropdown-item"><h4>
          Node.js
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Node.js/" class="nav-link">
  Node.js
</a></li></ul></li><li class="dropdown-item"><h4>
          Python
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Python/" class="nav-link">
  Python 基础
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/Python/Flask/" class="nav-link">
  Flask
</a></li></ul></li><li class="dropdown-item"><h4>
          数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/DataBase/MySQL/" class="nav-link">
  MySQL
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/DataBase/Redis/" class="nav-link">
  Redis
</a></li></ul></li><li class="dropdown-item"><h4>
          PHP
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/PHP/" class="nav-link">
  PHP 基础
</a></li><li class="dropdown-subitem"><a href="/TechnicalNotes/back-end/PHP/ThinkPHP/" class="nav-link">
  ThinkPHP
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/TechnicalNotes/Other/Photoshop/" class="nav-link">
  Photoshop
</a></li><li class="dropdown-item"><!----> <a href="/TechnicalNotes/Other/Git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/TechnicalNotes/Other/WinPE/" class="nav-link">
  WinPE
</a></li><li class="dropdown-item"><!----> <a href="/TechnicalNotes/Other/Minecraft/" class="nav-link">
  Minecraft
</a></li><li class="dropdown-item"><!----> <a href="/TechnicalNotes/Other/FL Studio/" class="nav-link">
  FL Studio
</a></li></ul></div></div><div class="nav-item"><a href="https://firpe.cn/about" target="_blank" rel="noopener noreferrer" class="nav-link external">
  关于
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://firpe.cn/donate" target="_blank" rel="noopener noreferrer" class="nav-link external">
  投食 
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>DataInterface</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/TechnicalNotes/front-end/DataInterface/" aria-current="page" class="active sidebar-link">数据结构与算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#基本概念" class="sidebar-link">基本概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#数据" class="sidebar-link">数据</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#数据元素" class="sidebar-link">数据元素</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#数据项" class="sidebar-link">数据项</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#数据、数据元素、数据项之间的关系" class="sidebar-link">数据、数据元素、数据项之间的关系</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#数据对象" class="sidebar-link">数据对象</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#数据结构" class="sidebar-link">数据结构</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#逻辑结构和物理结构" class="sidebar-link">逻辑结构和物理结构</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#时间复杂度" class="sidebar-link">时间复杂度</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#递归" class="sidebar-link">递归</a></li></ul></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#栈" class="sidebar-link">栈</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#什么是栈" class="sidebar-link">什么是栈</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#程序中的栈结构" class="sidebar-link">程序中的栈结构</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#栈结构实现" class="sidebar-link">栈结构实现</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#javascript-代码实现栈结构" class="sidebar-link">JavaScript 代码实现栈结构</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#测试封装的栈结构" class="sidebar-link">测试封装的栈结构</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#栈结构的简单应用" class="sidebar-link">栈结构的简单应用</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#代码实现" class="sidebar-link">代码实现</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#测试" class="sidebar-link">测试</a></li></ul></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#队列" class="sidebar-link">队列</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#队列图解" class="sidebar-link">队列图解</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#队列在程序中的应用" class="sidebar-link">队列在程序中的应用</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#队列的实现" class="sidebar-link">队列的实现</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#队列常见的操作" class="sidebar-link">队列常见的操作</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#代码实现-2" class="sidebar-link">代码实现</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#测试代码" class="sidebar-link">测试代码</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#队列的应用" class="sidebar-link">队列的应用</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#代码实现-3" class="sidebar-link">代码实现</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#测试代码-2" class="sidebar-link">测试代码</a></li></ul></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#线性表" class="sidebar-link">线性表</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#定义-2" class="sidebar-link">定义</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#特点" class="sidebar-link">特点</a></li></ul></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#链表" class="sidebar-link">链表</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#单向链表" class="sidebar-link">单向链表</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#双向链表" class="sidebar-link">双向链表</a></li></ul></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#集合" class="sidebar-link">集合</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#集合特点" class="sidebar-link">集合特点</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#封装集合" class="sidebar-link">封装集合</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#集合间的操作" class="sidebar-link">集合间的操作</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#集合的完整实现" class="sidebar-link">集合的完整实现</a></li></ul></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#字典" class="sidebar-link">字典</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#字典特点" class="sidebar-link">字典特点</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#字典和映射的关系" class="sidebar-link">字典和映射的关系</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#字典常见的操作" class="sidebar-link">字典常见的操作</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#字典封装" class="sidebar-link">字典封装</a></li></ul></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#哈希表" class="sidebar-link">哈希表</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#认识哈希化" class="sidebar-link">认识哈希化</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#哈希表的一些概念" class="sidebar-link">哈希表的一些概念</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#地址的冲突" class="sidebar-link">地址的冲突</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#哈希函数" class="sidebar-link">哈希函数</a></li></ul></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#封装哈希表" class="sidebar-link">封装哈希表</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#哈希表常见操作" class="sidebar-link">哈希表常见操作</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#哈希函数的简单实现" class="sidebar-link">哈希函数的简单实现</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#哈希表的实现" class="sidebar-link">哈希表的实现</a></li></ul></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#哈希表的扩容与压缩" class="sidebar-link">哈希表的扩容与压缩</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#resize-的实现" class="sidebar-link">resize() 的实现</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#选择质数作为哈希表容量" class="sidebar-link">选择质数作为哈希表容量</a></li></ul></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#哈希表完整实现" class="sidebar-link">哈希表完整实现</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#树结构" class="sidebar-link">树结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#什么是树" class="sidebar-link">什么是树？</a></li></ul></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#二叉树" class="sidebar-link">二叉树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#二叉树的概念" class="sidebar-link">二叉树的概念</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#二叉树的组成" class="sidebar-link">二叉树的组成</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#二叉树的五种形态" class="sidebar-link">二叉树的五种形态</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#二叉树的特性" class="sidebar-link">二叉树的特性</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#特殊的二叉树" class="sidebar-link">特殊的二叉树</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#二叉树的数据存储" class="sidebar-link">二叉树的数据存储</a></li></ul></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#二叉搜索树" class="sidebar-link">二叉搜索树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#二叉搜索树应用举例" class="sidebar-link">二叉搜索树应用举例</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#二叉搜索树的封装" class="sidebar-link">二叉搜索树的封装</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#二叉搜索树的常见操作" class="sidebar-link">二叉搜索树的常见操作：</a></li></ul></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#平衡树" class="sidebar-link">平衡树</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#图" class="sidebar-link">图</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#什么是图" class="sidebar-link">什么是图？</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#图的术语" class="sidebar-link">图的术语</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#现实建模" class="sidebar-link">现实建模</a></li></ul></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#图的表示" class="sidebar-link">图的表示</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#顶点表示" class="sidebar-link">顶点表示</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#邻接矩阵" class="sidebar-link">邻接矩阵</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#邻接表" class="sidebar-link">邻接表</a></li></ul></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#图的封装" class="sidebar-link">图的封装</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#创建图类" class="sidebar-link">创建图类</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#添加方法" class="sidebar-link">添加方法</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#测试代码-3" class="sidebar-link">测试代码</a></li></ul></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#图的遍历" class="sidebar-link">图的遍历</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#遍历的方式" class="sidebar-link">遍历的方式</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#广度优先搜索-bfs" class="sidebar-link">广度优先搜索(BFS)</a></li><li class="sidebar-sub-header"><a href="/TechnicalNotes/front-end/DataInterface/#深度优先搜索-dfs" class="sidebar-link">深度优先搜索(DFS)</a></li></ul></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="数据结构与算法"><a href="#数据结构与算法" class="header-anchor">#</a> 数据结构与算法</h1> <p>算法是解决特定问题<strong>求解步骤的描述</strong>，在计算机中<strong>表现为</strong>指令的有限序列，并且每条指令<strong>表示</strong>一个或多个操作。简而言之，<strong>算法是描述解决问题的方法</strong>。</p> <h2 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h2> <h3 id="数据"><a href="#数据" class="header-anchor">#</a> 数据</h3> <p>数据(Data)是客观事物的符号表示，是所有<strong>能输入到计算机中并被计算机程序处理</strong>的符号的总称（集合）。是信息的载体；是对客观事物的符号化表示；可以被计算机<strong>识别、存储和加工</strong>。数据不仅仅包含整型、实型等<strong>数值类型</strong>，还包含图形、图像、声音、视频及动画等<strong>非数值类型</strong>。</p> <ul><li>对于整型、实型等数值类型,可以进行<strong>数值计算</strong>；</li> <li>对于字符数据类型，就需要进行非数值的处理。而声音、图像、视频等其实是可以通过<strong>编码</strong>的手段变成字符数据来处理；</li></ul> <h3 id="数据元素"><a href="#数据元素" class="header-anchor">#</a> 数据元素</h3> <p>数据元素(DataElement)是数据的<strong>基本单位</strong>，在计算机中通常作为一个整体进行考虑和处理。在有些情况下，数据元素也称为<strong>元素、记录、节点、顶点</strong>等。</p> <ul><li>例如一名学生记录，树中棋盘的一个格局（状态），以及图中的一个顶点等。</li></ul> <h3 id="数据项"><a href="#数据项" class="header-anchor">#</a> 数据项</h3> <p>数据项(Data Item)是组成数据元素的、有独立含义的、不可分割的<strong>最小单位</strong>。</p> <ul><li>例如，学生基本信息表中的学号、姓名、性别等都是数据项。</li> <li>数据项是“数据的最小单位。但真正讨论问题时，<strong>数据元素才是数据结构中建立数据模型的着眼点</strong>。就像我们讨论一部电影时，是讨论这部电影角色这样的数据元素”，而不是针对这个角色的姓名或者年龄这样的“数据项”去研究分析。</li></ul> <h3 id="数据、数据元素、数据项之间的关系"><a href="#数据、数据元素、数据项之间的关系" class="header-anchor">#</a> 数据、数据元素、数据项之间的关系</h3> <p>数据 &gt; 数据元素 &gt; 数据项</p> <ul><li>学生表 &gt; 个人记录 &gt; 学号/姓名</li></ul> <h3 id="数据对象"><a href="#数据对象" class="header-anchor">#</a> 数据对象</h3> <p>数据对象(DataObject)是性质相同的数据元素的集合，是数据的一个<strong>子集</strong>。</p> <ul><li>例如：整数数据对象是集合N={0, ±1,±2,...}, 字母字符数据对象是集合C={'A','B', ...‘Z’,'a','b', ...， 'z'}, 学生基本信息表也可以是一个数据对象。</li> <li>由此可以看出，不论数据元素集合是无限集（如整数集），或是有限集（如字母字符集），还是由多个数据项组成的复合数据元素（如学生表）的集合，只要集合内元素的性质均相同，都可称之为一个数据对象。</li></ul> <h3 id="数据结构"><a href="#数据结构" class="header-anchor">#</a> 数据结构</h3> <p>数据结构(Data Structure)是<strong>相互之间存在一种或多种特定关系的数据元素的集合</strong>。换句话说，数据结构是带”结构＂的数据元素的集合，“结构”就是指数据元素之间存在的关系。</p> <p>数据结构包括以下三个方面的内容:</p> <ol><li>数据元素之间的逻辑关系，也称为<strong>逻辑结构</strong>。</li> <li>数据元素及其关系在计算机内存中的表示(又称为映像)，称为数据的<strong>物理结构</strong>或数据的<strong>存储结构</strong>。</li> <li>数据的<strong>运算和实现</strong>，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现。</li></ol> <h3 id="逻辑结构和物理结构"><a href="#逻辑结构和物理结构" class="header-anchor">#</a> 逻辑结构和物理结构</h3> <ul><li><p>逻辑结构</p> <p>数据的逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。因此，数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。数据的逻辑结构有两个要素：一是<strong>数据元素</strong>；二是<strong>关系</strong>。</p></li> <li><p>物理结构：<strong>数据的逻辑结构在计算机中(内存)的存储形式</strong>。分为顺序存储结构、链式存储结构、索引存储结构、散列存储结构。</p> <ol><li><p>顺序存储结构
顺序存储结构是把数据元素存放在连续的存储单元里，数据元素之间的逻辑关系是通过数据元素的位置。(在前面的数据元素就存在前面；在后面的数据元素就存在后面)。C语言用数组来实现顺序存储结构。</p> <p><img src="/TechnicalNotes/assets/img/顺序存储结构.b723525a.png" alt="顺序存储结构"></p></li> <li><p>链式存储结构
用一组任意的存储单元存储数据元素(可能连续也可能不连续)，数据元素之间的逻辑关系用指针来表示(用指针存放后继元素的存储地址)。C语言中用指针来实现链式存储结构。</p></li></ol> <p><img src="/TechnicalNotes/assets/img/链式存储结构.3e4515bc.png" alt="链式存储结构"></p> <p><img src="/TechnicalNotes/assets/img/链式存储结构2.898ceae5.png" alt="链式存储结构2"></p> <ol start="3"><li><p>索引存储结构</p> <p>在存储节点信息的同时，还建立附加索引。索引表中的每一项称为一个索引项，索引项的一般形式是：(关键字，地址）。关键字是能唯一标识一个结点的那些数据项。</p> <ol><li>若每个结点在索引表中都有一个索引项，则该索引表称之为稠密索引（Dense Index)。</li> <li>若一组结点在索引表中只对应一个索引项，则该索引表称之为稀疏索引（Sparse Index)。</li></ol></li> <li><p>散列存储结构</p></li></ol> <p><img src="/TechnicalNotes/assets/img/散列存储结构.e04d2197.png" alt="散列存储结构"></p> <h3 id="时间复杂度"><a href="#时间复杂度" class="header-anchor">#</a> 时间复杂度</h3> <h4 id="定义"><a href="#定义" class="header-anchor">#</a> 定义</h4> <p>时间复杂度：所需消耗的时间即<strong>基本操作执行次数</strong>。</p> <h4 id="常见时间复杂度"><a href="#常见时间复杂度" class="header-anchor">#</a> 常见时间复杂度</h4> <table><thead><tr><th style="text-align:center;">执行次数</th> <th style="text-align:center;">阶</th> <th style="text-align:center;">非正式术语</th></tr></thead> <tbody><tr><td style="text-align:center;">12</td> <td style="text-align:center;">O(1)</td> <td style="text-align:center;">常数阶</td></tr> <tr><td style="text-align:center;">2n + 3</td> <td style="text-align:center;">O(n)</td> <td style="text-align:center;">线性阶</td></tr> <tr><td style="text-align:center;">3n? + 2n + 1</td> <td style="text-align:center;">O(n?)</td> <td style="text-align:center;">平方阶</td></tr> <tr><td style="text-align:center;">5log?n + 20</td> <td style="text-align:center;">O(logn)</td> <td style="text-align:center;">对数阶</td></tr> <tr><td style="text-align:center;">2n + 3nlog?n + 19</td> <td style="text-align:center;">O(nlogn)</td> <td style="text-align:center;">线性对数阶</td></tr> <tr><td style="text-align:center;">6n? + 2n? + 3n + 4</td> <td style="text-align:center;">O(n?)</td> <td style="text-align:center;">立方阶</td></tr> <tr><td style="text-align:center;">2^n</td> <td style="text-align:center;">O(2^n)</td> <td style="text-align:center;">指数阶</td></tr> <tr><td style="text-align:center;">2!</td> <td style="text-align:center;">O(n!)</td> <td style="text-align:center;">阶层阶</td></tr></tbody></table> <p>从小到大依次：O(1) &lt; O(login) &lt; O(nlogin) &lt; O(n?) &lt; O(n?) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)</p> <h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="header-anchor">#</a> 时间复杂度分析</h4> <ol><li>只关注循环执行次数最多的一段代码。</li> <li>总复杂度等于最高阶项的复杂度。</li> <li>嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。</li></ol> <h4 id="时间复杂度的计算"><a href="#时间复杂度的计算" class="header-anchor">#</a> 时间复杂度的计算</h4> <ol><li><p>用<strong>常数 1</strong>取代<strong>运行时间中的</strong>所有加法常数。</p></li> <li><p>在修改后的运行次数函数中，<strong>只保留最高阶项</strong>。</p></li> <li><p>如果最高阶项<strong>存在且不是 1</strong>，<strong>则</strong>去<strong>除与这个项相乘的常数</strong>（即O(2n^2) = O(n^2)），得到的结果就是大 O 阶。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j<span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 时间复杂度为: O(1) </span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ol></li></ul> <h3 id="递归"><a href="#递归" class="header-anchor">#</a> 递归</h3> <p>递归即在运行的过程中调用自己。</p> <h4 id="递归需满足的条件"><a href="#递归需满足的条件" class="header-anchor">#</a> 递归需满足的条件</h4> <ol><li>问题的解可以分解为几个子问题的解。</li> <li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。</li> <li>不能无限制地调用本身，需存在终止条件。</li></ol> <h4 id="递归模板"><a href="#递归模板" class="header-anchor">#</a> 递归模板</h4> <div class="language-C extra-class"><pre class="language-c"><code><span class="token keyword">void</span> 函数名<span class="token punctuation">(</span>参数<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>终止条件<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    函数名<span class="token punctuation">(</span>参数<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="栈"><a href="#栈" class="header-anchor">#</a> 栈</h2> <h3 id="什么是栈"><a href="#什么是栈" class="header-anchor">#</a> 什么是栈</h3> <p>栈（stack）是一种运算受限的线性表：</p> <ul><li><code>LIFO（last in first out）</code>表示就是后进入的元素，第一个弹出栈空间。类似于自动餐托盘，最后放上的托盘，往往先把拿出去使用。</li> <li>其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。</li> <li>向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；</li> <li>从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</li></ul> <p>如下图所示：
<img src="/TechnicalNotes/assets/img/image.71xt32okr3k0.a54f2ba8.png" alt="image"></p> <p>栈的特点：<strong>先进后出，后进先出</strong>。</p> <h3 id="程序中的栈结构"><a href="#程序中的栈结构" class="header-anchor">#</a> 程序中的栈结构</h3> <ul><li>函数调用栈：A(B(C(D())))：
即 A 函数中调用 B，B 调用 C，C 调用 D；在 A 执行的过程中会将 A 压入栈，随后 B 执行时 B 也被压入栈，函数 C 和 D 执行时也会被压入栈。所以当前栈的顺序为：A-&gt;B-&gt;C-&gt;D（栈顶）；函数 D 执行完之后，会弹出栈被释放，弹出栈的顺序为 D-&gt;C-&gt;B-&gt;A;</li> <li>递归：
为什么没有停止条件的递归会造成栈溢出？比如函数 A 为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数 A 压入栈，最后造成栈溢出（Queue Overfloat）。</li></ul> <h3 id="栈结构实现"><a href="#栈结构实现" class="header-anchor">#</a> 栈结构实现</h3> <h4 id="栈常见的操作"><a href="#栈常见的操作" class="header-anchor">#</a> 栈常见的操作</h4> <ul><li><code>push()</code> 添加一个新元素到栈顶位置。</li> <li><code>pop()</code> 移除栈顶的元素，同时返回被移除的元素。</li> <li><code>peek()</code> 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）。</li> <li><code>isEmpty()</code> 如果栈里没有任何元素就返回 <code>true</code>，否则返回 <code>false</code>。</li> <li><code>size()</code> 返回栈里的元素个数。这个方法和数组的 <code>length</code> 属性类似。</li> <li><code>toString()</code> 将栈结构的内容以字符串的形式返回。</li></ul> <h3 id="javascript-代码实现栈结构"><a href="#javascript-代码实现栈结构" class="header-anchor">#</a> JavaScript 代码实现栈结构</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 栈结构的封装</span>
<span class="token keyword">class</span> <span class="token class-name">Stack</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// push(item) 压栈操作，往栈里面添加元素</span>
  <span class="token function">push</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// pop() 出栈操作，从栈中取出元素，并返回取出的那个元素</span>
  <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// peek() 查看栈顶元素</span>
  <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// isEmpty() 判断栈是否为空</span>
  <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// size() 获取栈中元素个数</span>
  <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// toString() 返回以字符串形式的栈内元素数据</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result <span class="token operator">+=</span> item <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="测试封装的栈结构"><a href="#测试封装的栈结构" class="header-anchor">#</a> 测试封装的栈结构</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// push() 测试</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; [1, 2, 3]</span>

<span class="token comment">// pop() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 3</span>

<span class="token comment">// peek() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 2</span>

<span class="token comment">// isEmpty() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; false</span>

<span class="token comment">// size() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 2</span>

<span class="token comment">// toString() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 1 2</span>
</code></pre></div><h3 id="栈结构的简单应用"><a href="#栈结构的简单应用" class="header-anchor">#</a> 栈结构的简单应用</h3> <p>利用栈结构的特点封装实现十进制转换为二进制的方法。</p> <h3 id="代码实现"><a href="#代码实现" class="header-anchor">#</a> 代码实现</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">dec2bin</span><span class="token punctuation">(</span><span class="token parameter">dec</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// new 一个 Stack，保存余数</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 当不确定循环次数时，使用 while 循环</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>dec <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 除二取余法</span>
    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>dec <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取余数，放入栈中</span>
    dec <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>dec <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 除数除以二，向下取整</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> binaryString <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
  <span class="token comment">// 不断地从栈中取出元素（0 或 1），并拼接到一起。</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    binaryString <span class="token operator">+=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> binaryString<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="测试"><a href="#测试" class="header-anchor">#</a> 测试</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// dec2bin() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">dec2bin</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 1100100</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">dec2bin</span><span class="token punctuation">(</span><span class="token number">88</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 1011000</span>
</code></pre></div><h2 id="队列"><a href="#队列" class="header-anchor">#</a> 队列</h2> <p>队列（Queue）是一种运算受限的线性表，特点：先进先出。(FIFO：First In First Out)</p> <p><strong>受限之处：</strong></p> <ul><li>只允许在表的前端（front）进行删除操作。</li> <li>只允许在表的后端（rear）进行插入操作。</li></ul> <p>生活中类似队列结构的场景：</p> <ul><li>排队，比如在电影院，商场，甚至是厕所排队。</li> <li>优先排队的人，优先处理。 (买票、结账、WC)。</li></ul> <p><img src="/TechnicalNotes/assets/img/image.5mmiw2kdwbs0.5b83e4df.png" alt="image"></p> <h3 id="队列图解"><a href="#队列图解" class="header-anchor">#</a> 队列图解</h3> <p><img src="/TechnicalNotes/assets/img/image.mq92bw3am0g.4674acec.png" alt="image"></p> <h3 id="队列在程序中的应用"><a href="#队列在程序中的应用" class="header-anchor">#</a> 队列在程序中的应用</h3> <ul><li>打印队列：计算机打印多个文件的时候，需要排队打印。</li> <li>线程队列：当开启多线程时，当新开启的线程所需的资源不足时就先放入线程队列，等待 CPU 处理。</li></ul> <h3 id="队列的实现"><a href="#队列的实现" class="header-anchor">#</a> 队列的实现</h3> <p>队列的实现和栈一样，有两种方案：</p> <ul><li>基于数组实现。</li> <li>基于链表实现。</li></ul> <h3 id="队列常见的操作"><a href="#队列常见的操作" class="header-anchor">#</a> 队列常见的操作</h3> <ul><li><code>enqueue(element)</code> 向队列尾部添加一个（或多个）新的项。</li> <li><code>dequeue()</code> 移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。</li> <li><code>front()</code> 返回队列中的第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息与 Map 类的 peek 方法非常类似）。</li> <li><code>isEmpty()</code> 如果队列中不包含任何元素，返回 true，否则返回 false。</li> <li><code>size()</code> 返回队列包含的元素个数，与数组的 length 属性类似。</li> <li><code>toString()</code> 将队列中的内容，转成字符串形式。</li></ul> <h3 id="代码实现-2"><a href="#代码实现-2" class="header-anchor">#</a> 代码实现</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Queue</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// enqueue(item) 入队，将元素加入到队列中</span>
  <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// dequeue() 出队，从队列中删除队头元素，返回删除的那个元素</span>
  <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// front() 查看队列的队头元素</span>
  <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// isEmpty() 查看队列是否为空</span>
  <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// size() 查看队列中元素的个数</span>
  <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// toString() 将队列中的元素以字符串形式返回</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result <span class="token operator">+=</span> item <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="测试代码"><a href="#测试代码" class="header-anchor">#</a> 测试代码</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// enqueue() 测试</span>
queue<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
queue<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
queue<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
queue<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token string">&quot;d&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span>

<span class="token comment">// dequeue() 测试</span>
queue<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
queue<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; [&quot;c&quot;, &quot;d&quot;]</span>

<span class="token comment">// front() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; c</span>

<span class="token comment">// isEmpty() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; false</span>

<span class="token comment">// size() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 2</span>

<span class="token comment">// toString() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; c d</span>
</code></pre></div><h3 id="队列的应用"><a href="#队列的应用" class="header-anchor">#</a> 队列的应用</h3> <p>使用队列实现小游戏：<strong>击鼓传花</strong>。</p> <p>分析：传入一组数据集合和设定的数字 number，循环遍历数组内元素，遍历到的元素为指定数字 number 时将该元素删除，直至数组剩下一个元素。</p> <h3 id="代码实现-3"><a href="#代码实现-3" class="header-anchor">#</a> 代码实现</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 利用队列结构的特点实现击鼓传花游戏求解方法的封装</span>
<span class="token keyword">function</span> <span class="token function">passGame</span><span class="token punctuation">(</span><span class="token parameter">nameList<span class="token punctuation">,</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1、new 一个 Queue 对象</span>
  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 2、将 nameList 里面的每一个元素入队</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> name <span class="token keyword">of</span> nameList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    queue<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 3、开始数数</span>
  <span class="token comment">// 队列中只剩下 1 个元素时就停止数数</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 不是 number 时，重新加入到队尾</span>
    <span class="token comment">// 是 number 时，将其删除</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> number <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// number 数字之前的人重新放入到队尾（即把队头删除的元素，重新加入到队列中）</span>
      queue<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// number 对应这个人，直接从队列中删除</span>
    <span class="token comment">// 由于队列没有像数组一样的下标值不能直接取到某一元素，</span>
    <span class="token comment">// 所以采用，把 number 前面的 number - 1 个元素先删除后添加到队列末尾，</span>
    <span class="token comment">// 这样第 number 个元素就排到了队列的最前面，可以直接使用 dequeue 方法进行删除</span>
    queue<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 4、获取最后剩下的那个人</span>
  <span class="token keyword">const</span> endName <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 5、返回这个人在原数组中对应的索引</span>
  <span class="token keyword">return</span> nameList<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>endName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="测试代码-2"><a href="#测试代码-2" class="header-anchor">#</a> 测试代码</h3> <h2 id="线性表"><a href="#线性表" class="header-anchor">#</a> 线性表</h2> <h3 id="定义-2"><a href="#定义-2" class="header-anchor">#</a> 定义</h3> <p>线性表是由n(n≥0)个数据特性相同的元素构成的有限序列。</p> <p><img src="/TechnicalNotes/assets/img/45031861e452f0c074b4c35529161e4c16cef9f9.png@674w_228h_progressive-16473974669212.39cbf771.png" alt="img"></p> <h3 id="特点"><a href="#特点" class="header-anchor">#</a> 特点</h3> <ul><li>线性表中元素的个数n(n≥O)定义为线性表的长度，n=O时称为空表。</li> <li>将非空的线性表(n&gt;O)记作(a1，a2，a3，...，an)</li> <li>这里的数据元素ai(1≤i≤n)只是个抽象的符号，其具体含义在不同情况下可以不同。</li> <li>在非空的线性表，有且仅有一个开始结点a1,它没有直接前趋，而仅有一个直接后继a2;</li> <li>有且仅有一个终端结点an,它没有直接后继，而仅有一个直接前趋an-1;</li> <li>其余的内部结点ai,(2&lt;i&lt;n-1)都有且仅有一个直接前趋ai-1和一个直接后继ai+1；</li></ul> <h2 id="链表"><a href="#链表" class="header-anchor">#</a> 链表</h2> <p>链表和数组一样，可以用于存储一系列的元素，但是链表和数组的实现机制完全不同。</p> <ul><li><p>数组</p> <ul><li><p>存储多个元素，数组（或列表）可能是最常用的数据结构。</p></li> <li><p>几乎每一种编程语言都有默认实现数组结构，提供了一个便利的 <code>[]</code> 语法来访问数组元素。</p></li> <li><p>数组缺点：</p> <p>数组的创建需要申请一段连续的内存空间(一整块内存)，并且大小是固定的，当前数组不能满足容量需求时，需要扩容。 (一般情况下是申请一个更大的数组，比如 2 倍，然后将原数组中的元素复制过去)</p> <p>在数组开头或中间位置插入数据的成本很高，需要进行大量元素的位移。</p></li></ul></li> <li><p>链表</p> <ul><li><p>存储多个元素，另外一个选择就是使用链表。</p></li> <li><p>不同于数组，链表中的元素在内存中不必是连续的空间。</p></li> <li><p>链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(有些语言称为指针)组成。</p></li> <li><p>链表优点：</p> <p>内存空间不必是连续的，可以充分利用计算机的内存，实现灵活的内存动态管理。</p> <p>链表不必在创建时就确定大小，并且大小可以无限延伸下去。</p> <p>链表在插入和删除数据时，时间复杂度可以达到 O(1)，相对数组效率高很多。</p></li> <li><p>链表缺点：</p> <p>访问任何一个位置的元素时，需要从头开始访问。(无法跳过第一个元素访问任何一个元素)</p> <p>无法通过下标值直接访问元素，需要从头开始一个个访问，直到找到对应的元素。</p> <p>虽然可以轻松地到达下一个节点，但是回到前一个节点是很难的。</p></li></ul></li></ul> <h3 id="单向链表"><a href="#单向链表" class="header-anchor">#</a> 单向链表</h3> <p>单向链表类似于火车，有一个火车头，火车头会连接一个节点，节点上有乘客，并且这个节点会连接下一个节点，以此类推。</p> <ul><li><p>链表的火车结构</p> <p><img src="/TechnicalNotes/assets/img/image.27xtn3c52zwg.87476b2d.png" alt="链表的火车结构"></p></li> <li><p>链表的数据结构</p> <p>head 属性指向链表的第一个节点。<br>
链表中的最后一个节点指向 <code>null</code>。
当链表中一个节点也没有的时候，head 直接指向 <code>null</code>。</p> <p><img src="/TechnicalNotes/assets/img/image.37j1by46a120.2b02e9fc.png" alt="链表的数据结构"></p></li> <li><p>给火车加上数据后的结构</p> <p><img src="/TechnicalNotes/assets/img/image.664djiie2t80.ad3af99c.png" alt="给火车加上数据后的结构"></p></li></ul> <h4 id="链表中的常见操作"><a href="#链表中的常见操作" class="header-anchor">#</a> 链表中的常见操作</h4> <ul><li><code>append(element)</code> 向链表尾部添加一个新的项。</li> <li><code>insert(position, element)</code> 向链表的特定位置插入一个新的项。</li> <li><code>get(position)</code> 获取对应位置的元素。</li> <li><code>indexOf(element)</code> 返回元素在链表中的索引。如果链表中没有该元素就返回-1。</li> <li><code>update(position, element)</code> 修改某个位置的元素。</li> <li><code>removeAt(position)</code> 从链表的特定位置移除一项。</li> <li><code>remove(element)</code> 从链表中移除一项。</li> <li><code>isEmpty()</code> 如果链表中不包含任何元素，返回 trun，如果链表长度大于 0 则返回 false。</li> <li><code>size()</code> 返回链表包含的元素个数，与数组的 length 属性类似。</li> <li><code>toString()</code> 由于链表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。</li></ul> <h4 id="单向链表的封装"><a href="#单向链表的封装" class="header-anchor">#</a> 单向链表的封装</h4> <h5 id="创建单向链表类"><a href="#创建单向链表类" class="header-anchor">#</a> 创建单向链表类</h5> <p>先创建单向链表类 LinkedList，添加基本属性，再逐步实现单向链表的常用方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">LinkedList</span> <span class="token punctuation">{</span>
  <span class="token comment">// 初始链表长度为 0</span>
  length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token comment">// 初始 head 为 null，head 指向链表的第一个节点</span>
  head <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 内部类（链表里的节点 Node）</span>
  Node <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token punctuation">{</span>
    data<span class="token punctuation">;</span>
    next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="实现-append-方法"><a href="#实现-append-方法" class="header-anchor">#</a> 实现 append() 方法</h5> <ul><li>代码实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// append() 往链表尾部追加数据</span>
<span class="token function">append</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">// 1、创建新节点</span>
    <span class="token keyword">const</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">this<span class="token punctuation">.</span>Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、追加新节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">// 链表长度为 0 时，即只有 head 的时候</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 链表长度大于 0 时，在最后面添加新节点</span>
    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>

    <span class="token comment">// 当 currentNode.next 不为空时，</span>
    <span class="token comment">// 循序依次找最后一个节点，即节点的 next 为 null 时</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>next <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 最后一个节点的 next 指向新节点</span>
    currentNode<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3、追加完新节点后，链表长度 + 1</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>过程图解</p> <ul><li><p>首先让 <code>currentNode</code> 指向第一个节点。</p> <p><img src="/TechnicalNotes/assets/img/image.5iskrdf4nu40.75986610.png" alt="image"></p></li> <li><p>通过 <code>while</code> 循环使 <code>currentNode</code> 指向最后一个节点，最后通过 <code>currentNode.next = newNode</code>，让最后一个节点指向新节点 <code>newNode</code>。</p> <p><img src="/TechnicalNotes/assets/img/image.4mw3bx5g80m0.3057c0cd.png" alt="image"></p></li></ul></li> <li><p>代码测试</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> linkedList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 测试 append 方法</span>
linkedList<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
linkedList<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
linkedList<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;C&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>linkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><img src="/TechnicalNotes/assets/img/image.6kx4qbq8e5c.4c9e2df3.png" alt="image"></p> <h5 id="实现-tostring-方法"><a href="#实现-tostring-方法" class="header-anchor">#</a> 实现 toString() 方法</h5> <ul><li>代码实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>

    <span class="token comment">// 遍历所有的节点，拼接为字符串，直到节点为 null</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result <span class="token operator">+=</span> currentNode<span class="token punctuation">.</span>data <span class="token operator">+</span> <span class="token string">' '</span><span class="token punctuation">;</span>
    currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>代码测试</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 测试 toString 方法</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>linkedList<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; AA BB CC</span>
</code></pre></div><h5 id="实现-insert-方法"><a href="#实现-insert-方法" class="header-anchor">#</a> 实现 insert() 方法</h5> <ul><li>代码实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// insert() 在指定位置（position）插入节点</span>
<span class="token function">insert</span><span class="token punctuation">(</span><span class="token parameter">position<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// position 新插入节点的位置</span>
    <span class="token comment">// position = 0 表示新插入后是第一个节点</span>
    <span class="token comment">// position = 1 表示新插入后是第二个节点，以此类推</span>

    <span class="token comment">// 1、对 position 进行越界判断，不能小于 0 或大于链表长度</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> position <span class="token operator">&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、创建新节点</span>
    <span class="token keyword">const</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">this<span class="token punctuation">.</span>Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 3、插入节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// position = 0 的情况</span>
    <span class="token comment">// 让新节点的 next 指向 原来的第一个节点，即 head</span>
    newNode<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>

    <span class="token comment">// head 赋值为 newNode</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 0 &lt; position &lt;= length 的情况</span>

    <span class="token comment">// 初始化一些变量</span>
    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span> <span class="token comment">// 当前节点初始化为 head</span>
    <span class="token keyword">let</span> previousNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// head 的 上一节点为 null</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// head 的 index 为 0</span>

    <span class="token comment">// 在 0 ~ position 之间遍历，不断地更新 currentNode 和 previousNode</span>
    <span class="token comment">// 直到找到要插入的位置</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>index<span class="token operator">++</span> <span class="token operator">&lt;</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        previousNode <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>
        currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 在当前节点和当前节点的上一节点之间插入新节点，即它们的改变指向</span>
    newNode<span class="token punctuation">.</span>next <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>
    previousNode<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 更新链表长度</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> newNode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>代码测试</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 测试 insert 方法</span>
linkedList<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
linkedList<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&quot;456&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>linkedList<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 123 AA 456 BB CC</span>
</code></pre></div><h5 id="实现-getdata-方法"><a href="#实现-getdata-方法" class="header-anchor">#</a> 实现 getData() 方法</h5> <p>获取指定位置（position）的 data。</p> <ul><li>代码实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">getData</span><span class="token punctuation">(</span><span class="token parameter">position</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、position 越界判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> position <span class="token operator">&gt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、获取指定 position 节点的 data</span>
    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>index<span class="token operator">++</span> <span class="token operator">&lt;</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 3、返回 data</span>
    <span class="token keyword">return</span> currentNode<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>代码测试</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 测试 getData 方法</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>linkedList<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 123</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>linkedList<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; AA</span>
</code></pre></div><h5 id="实现-indexof-方法"><a href="#实现-indexof-方法" class="header-anchor">#</a> 实现 indexOf() 方法</h5> <p>indexOf(data) 返回指定 data 的 index，如果没有，返回 -1。</p> <ul><li>代码实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>data <span class="token operator">===</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> index<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    index<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>代码测试</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 测试 indexOf 方法</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>linkedList<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">&quot;AA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>linkedList<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">&quot;ABC&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; -1</span>
</code></pre></div><h5 id="实现-update-方法"><a href="#实现-update-方法" class="header-anchor">#</a> 实现 update() 方法</h5> <p>update(position, data) 修改指定位置节点的 data。</p> <ul><li>代码实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">position<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 涉及到 position 都要进行越界判断</span>
    <span class="token comment">// 1、position 越界判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> position <span class="token operator">&gt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、痛过循环遍历，找到指定 position 的节点</span>
    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>index<span class="token operator">++</span> <span class="token operator">&lt;</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3、修改节点 data</span>
    currentNode<span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>

    <span class="token keyword">return</span> currentNode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>代码测试</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 测试 update 方法</span>
linkedList<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;12345&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>linkedList<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 12345 AA 456 BB CC</span>
linkedList<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;54321&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>linkedList<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 12345 54321 456 BB CC</span>
</code></pre></div><h5 id="实现-removeat-方法"><a href="#实现-removeat-方法" class="header-anchor">#</a> 实现 removeAt() 方法</h5> <p>removeAt(position) 删除指定位置的节点。</p> <ul><li>代码实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">removeAt</span><span class="token punctuation">(</span><span class="token parameter">position</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、position 越界判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> position <span class="token operator">&gt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、删除指定 position 节点</span>
    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// position = 0 的情况</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// position &gt; 0 的情况</span>
    <span class="token comment">// 通过循环遍历，找到指定 position 的节点，赋值到 currentNode</span>

    <span class="token keyword">let</span> previousNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>index<span class="token operator">++</span> <span class="token operator">&lt;</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        previousNode <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>
        currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 巧妙之处，让上一节点的 next 指向到当前的节点的 next，相当于删除了当前节点。</span>
    previousNode<span class="token punctuation">.</span>next <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3、更新链表长度 -1</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> currentNode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>代码测试</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 测试 removeAt 方法</span>
linkedList<span class="token punctuation">.</span><span class="token function">removeAt</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>linkedList<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 12345 54321 456 CC</span>
</code></pre></div><h5 id="实现-remove-方法"><a href="#实现-remove-方法" class="header-anchor">#</a> 实现 remove() 方法</h5> <p>remove(data) 删除指定 data 所在的节点。</p> <ul><li>代码实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">remove</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeAt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>代码测试</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 测试 remove 方法</span>
linkedList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">&quot;CC&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>linkedList<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 12345 54321 456</span>
</code></pre></div><h5 id="实现-isempty-方法"><a href="#实现-isempty-方法" class="header-anchor">#</a> 实现 isEmpty() 方法</h5> <p>isEmpty() 判断链表是否为空。</p> <ul><li>代码实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>代码测试</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 测试 isEmpty 方法</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>linkedList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; false</span>
</code></pre></div><h5 id="实现-size-方法"><a href="#实现-size-方法" class="header-anchor">#</a> 实现 size() 方法</h5> <p>size() 获取链表的长度。</p> <ul><li>代码实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>代码测试</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 测试 size 方法</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>linkedList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 3</span>
</code></pre></div><ul><li>完整实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">LinkedList</span> <span class="token punctuation">{</span>
  <span class="token comment">// 初始链表长度为 0</span>
  length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token comment">// 初始 head 为 null，head 指向链表的第一个节点</span>
  head <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 内部类（链表里的节点 Node）</span>
  Node <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token punctuation">{</span>
    data<span class="token punctuation">;</span>
    next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// ------------ 链表的常见操作 ------------ //</span>

  <span class="token comment">// append() 往链表尾部追加数据</span>
  <span class="token function">append</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、创建新节点</span>
    <span class="token keyword">const</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">this<span class="token punctuation">.</span>Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、追加新节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 链表长度为 0 时，即只有 head 的时候</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 链表长度大于 0 时，在最后面添加新节点</span>
      <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>

      <span class="token comment">// 当 currentNode.next 不为空时，</span>
      <span class="token comment">// 循序依次找最后一个节点，即节点的 next 为 null 时</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>next <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// 最后一个节点的 next 指向新节点</span>
      currentNode<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3、追加完新节点后，链表长度 + 1</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// insert() 在指定位置（position）插入节点</span>
  <span class="token function">insert</span><span class="token punctuation">(</span><span class="token parameter">position<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// position 新插入节点的位置</span>
    <span class="token comment">// position = 0 表示新插入后是第一个节点</span>
    <span class="token comment">// position = 1 表示新插入后是第二个节点，以此类推</span>

    <span class="token comment">// 1、对 position 进行越界判断，不能小于 0 或大于链表长度</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> position <span class="token operator">&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、创建新节点</span>
    <span class="token keyword">const</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">this<span class="token punctuation">.</span>Node</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 3、插入节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// position = 0 的情况</span>
      <span class="token comment">// 让新节点的 next 指向 原来的第一个节点，即 head</span>
      newNode<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>

      <span class="token comment">// head 赋值为 newNode</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 0 &lt; position &lt;= length 的情况</span>

      <span class="token comment">// 初始化一些变量</span>
      <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span> <span class="token comment">// 当前节点初始化为 head</span>
      <span class="token keyword">let</span> previousNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// head 的 上一节点为 null</span>
      <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// head 的 index 为 0</span>

      <span class="token comment">// 在 0 ~ position 之间遍历，不断地更新 currentNode 和 previousNode</span>
      <span class="token comment">// 直到找到要插入的位置</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>index<span class="token operator">++</span> <span class="token operator">&lt;</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        previousNode <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>
        currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// 在当前节点和当前节点的上一节点之间插入新节点，即它们的改变指向</span>
      newNode<span class="token punctuation">.</span>next <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>
      previousNode<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 更新链表长度</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> newNode<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// getData() 获取指定位置的 data</span>
  <span class="token function">getData</span><span class="token punctuation">(</span><span class="token parameter">position</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、position 越界判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> position <span class="token operator">&gt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、获取指定 position 节点的 data</span>
    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>index<span class="token operator">++</span> <span class="token operator">&lt;</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3、返回 data</span>
    <span class="token keyword">return</span> currentNode<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// indexOf() 返回指定 data 的 index，如果没有，返回 -1。</span>
  <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>data <span class="token operator">===</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> index<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
      index<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// update() 修改指定位置节点的 data</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">position<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 涉及到 position 都要进行越界判断</span>
    <span class="token comment">// 1、position 越界判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> position <span class="token operator">&gt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、痛过循环遍历，找到指定 position 的节点</span>
    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
    <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>index<span class="token operator">++</span> <span class="token operator">&lt;</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3、修改节点 data</span>
    currentNode<span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>

    <span class="token keyword">return</span> currentNode<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// removeAt() 删除指定位置的节点</span>
  <span class="token function">removeAt</span><span class="token punctuation">(</span><span class="token parameter">position</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、position 越界判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> position <span class="token operator">&gt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、删除指定 position 节点</span>
    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// position = 0 的情况</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// position &gt; 0 的情况</span>
      <span class="token comment">// 通过循环遍历，找到指定 position 的节点，赋值到 currentNode</span>

      <span class="token keyword">let</span> previousNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

      <span class="token keyword">while</span> <span class="token punctuation">(</span>index<span class="token operator">++</span> <span class="token operator">&lt;</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        previousNode <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>
        currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// 巧妙之处，让上一节点的 next 指向到当前的节点的 next，相当于删除了当前节点。</span>
      previousNode<span class="token punctuation">.</span>next <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3、更新链表长度 -1</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> currentNode<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// remove() 删除指定 data 的节点</span>
  <span class="token function">remove</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeAt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// isEmpty() 判断链表是否为空</span>
  <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// size() 获取链表的长度</span>
  <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// toString() 链表数据以字符串形式返回</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>

    <span class="token comment">// 遍历所有的节点，拼接为字符串，直到节点为 null</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result <span class="token operator">+=</span> currentNode<span class="token punctuation">.</span>data <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
      currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="双向链表"><a href="#双向链表" class="header-anchor">#</a> 双向链表</h3> <ul><li><p>单向链表</p> <ul><li>只能从头遍历到尾或者从尾遍历到头（一般从头到尾）。</li> <li>链表相连的过程是单向的，实现原理是上一个节点中有指向下一个节点的引用。</li> <li>单向链表有一个比较明显的缺点：可以轻松到达下一个节点，但回到前一个节点很难，在实际开发中, 经常会遇到需要回到上一个节点的情况。</li></ul></li> <li><p>双向链表</p> <ul><li>既可以从头遍历到尾，也可以从尾遍历到头。</li> <li>链表相连的过程是双向的。实现原理是一个节点既有向前连接的引用，也有一个向后连接的引用。</li> <li>双向链表可以有效的解决单向链表存在的问题。</li> <li>双向链表缺点：
<ul><li>每次在插入或删除某个节点时，都需要处理四个引用，而不是两个，实现起来会困难些。</li> <li>相对于单向链表，所占内存空间更大一些。</li> <li>但是，相对于双向链表的便利性而言，这些缺点微不足道。</li></ul></li></ul></li></ul> <h4 id="双向链表结构"><a href="#双向链表结构" class="header-anchor">#</a> 双向链表结构</h4> <p><img src="/TechnicalNotes/assets/img/image.3xy769h90v20.9c2bb025.png" alt="image"></p> <ul><li>双向链表不仅有 head 指针指向第一个节点，而且有 tail 指针指向最后一个节点。</li> <li>每一个节点由三部分组成：item 储存数据、prev 指向前一个节点、next 指向后一个节点。</li> <li>双向链表的第一个节点的 prev 指向 null。</li> <li>双向链表的最后一个节点的 next 指向 null。</li></ul> <h4 id="双向链表常见的操作"><a href="#双向链表常见的操作" class="header-anchor">#</a> 双向链表常见的操作</h4> <ul><li><code>append(element)</code> 向链表尾部追加一个新元素。</li> <li><code>insert(position, element)</code> 向链表的指定位置插入一个新元素。</li> <li><code>getElement(position)</code> 获取指定位置的元素。</li> <li><code>indexOf(element)</code> 返回元素在链表中的索引。如果链表中没有该元素就返回 -1。</li> <li><code>update(position, element)</code> 修改指定位置上的元素。</li> <li><code>removeAt(position)</code> 从链表中的删除指定位置的元素。</li> <li><code>remove(element)</code> 从链表删除指定的元素。</li> <li><code>isEmpty()</code> 如果链表中不包含任何元素，返回 <code>trun</code>，如果链表长度大于 0 则返回 <code>false</code>。</li> <li><code>size()</code> 返回链表包含的元素个数，与数组的 <code>length</code> 属性类似。</li> <li><code>toString()</code> 由于链表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 <code>toString</code> 方法，让其只输出元素的值。</li> <li><code>forwardString()</code> 返回正向遍历节点字符串形式。</li> <li><code>backwordString()</code> 返回反向遍历的节点的字符串形式。</li></ul> <h4 id="双向链表的封装"><a href="#双向链表的封装" class="header-anchor">#</a> 双向链表的封装</h4> <ul><li><p>创建双向链表类 DoublyLinkedList</p> <ul><li>DoublyNode 类继承单向链表的 Node 类，新添加 <code>this.prev</code> 属性，该属性用于指向上一个节点。</li> <li>DoublyLinkedList 类继承 LinkedList 类，新添加 <code>this.tail</code> 属性，该属性指向末尾的节点。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 双向链表的节点类（继承单向链表的节点类）</span>
<span class="token keyword">class</span> <span class="token class-name">DoublyNode</span> <span class="token keyword">extends</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 双向链表类继承单向链表类</span>
<span class="token keyword">class</span> <span class="token class-name">DoublyLinkedList</span> <span class="token keyword">extends</span> <span class="token class-name">LinkedList</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h5 id="append-element"><a href="#append-element" class="header-anchor">#</a> append(element)</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// append(element) 往双向链表尾部追加一个新的元素</span>
<span class="token comment">// 重写 append()</span>
<span class="token function">append</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token comment">// 1、创建双向链表节点</span>
<span class="token keyword">const</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DoublyNode</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2、追加元素</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// ！！跟单向链表不同，不用通过循环找到最后一个节点</span>
  <span class="token comment">// 巧妙之处</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
  newNode<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="insert-position-element"><a href="#insert-position-element" class="header-anchor">#</a> insert(position, element)</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// insert(position, data) 插入元素</span>
<span class="token comment">// 重写 insert()</span>
<span class="token function">insert</span><span class="token punctuation">(</span><span class="token parameter">position<span class="token punctuation">,</span> element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、position 越界判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> position <span class="token operator">&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、创建新的双向链表节点</span>
    <span class="token keyword">const</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DoublyNode</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 3、判断多种插入情况</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 在第 0 个位置插入</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">//== 巧妙之处：相处腾出 this.head 空间，留个 newNode 来赋值 ==//</span>
        newNode<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>perv <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 在最后一个位置插入</span>

      <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
      newNode<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 在 0 ~ this.length 位置中间插入</span>

      <span class="token keyword">let</span> targetIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
      <span class="token keyword">let</span> previousNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

      <span class="token comment">// 找到要插入位置的节点</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>targetIndex<span class="token operator">++</span> <span class="token operator">&lt;</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        previousNode <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>
        currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// 交换节点信息</span>
      previousNode<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
      newNode<span class="token punctuation">.</span>prev <span class="token operator">=</span> previousNode<span class="token punctuation">;</span>

      newNode<span class="token punctuation">.</span>next <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>
      currentNode<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><h5 id="insert-position-element-2"><a href="#insert-position-element-2" class="header-anchor">#</a> insert(position, element)</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// insert(position, data) 插入元素</span>
<span class="token comment">// 重写 insert()</span>
  <span class="token function">insert</span><span class="token punctuation">(</span><span class="token parameter">position<span class="token punctuation">,</span> element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、position 越界判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> position <span class="token operator">&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、创建新的双向链表节点</span>
    <span class="token keyword">const</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DoublyNode</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 3、判断多种插入情况</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 在第 0 个位置插入</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">//== 巧妙之处：相处腾出 this.head 空间，留个 newNode 来赋值 ==//</span>
        newNode<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>perv <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 在最后一个位置插入</span>

      <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
      newNode<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 在 0 ~ this.length 位置中间插入</span>

      <span class="token keyword">let</span> targetIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
      <span class="token keyword">let</span> previousNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

      <span class="token comment">// 找到要插入位置的节点</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>targetIndex<span class="token operator">++</span> <span class="token operator">&lt;</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        previousNode <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>
        currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// 交换节点信息</span>
      previousNode<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
      newNode<span class="token punctuation">.</span>prev <span class="token operator">=</span> previousNode<span class="token punctuation">;</span>

      newNode<span class="token punctuation">.</span>next <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>
      currentNode<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><h5 id="removeat-position"><a href="#removeat-position" class="header-anchor">#</a> removeAt(position)</h5> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// removeAt() 删除指定位置的节点</span>
  <span class="token comment">// 重写 removeAt()</span>
  <span class="token function">removeAt</span><span class="token punctuation">(</span><span class="token parameter">position</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、position 越界判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> position <span class="token operator">&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、根据不同情况删除元素</span>
    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 删除第一个节点的情况</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 链表内只有一个节点的情况</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 链表内有多个节点的情况</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 删除最后一个节点的情况</span>

      currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 删除 0 ~ this.length - 1 里面节点的情况</span>

      <span class="token keyword">let</span> targetIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> previousNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>targetIndex<span class="token operator">++</span> <span class="token operator">&lt;</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        previousNode <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>
        currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      previousNode<span class="token punctuation">.</span>next <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
      currentNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>perv <span class="token operator">=</span> previousNode<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> currentNode<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><h5 id="update-position-data"><a href="#update-position-data" class="header-anchor">#</a> update(position, data)</h5> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// update(position, data) 修改指定位置的节点</span>
  <span class="token comment">// 重写 update()</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">position<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、删除 position 位置的节点</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeAt</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、在 position 位置插入元素</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><h5 id="forwardtostring"><a href="#forwardtostring" class="header-anchor">#</a> forwardToString()</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// forwardToString() 链表数据从前往后以字符串形式返回</span>
  <span class="token function">forwardToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>

    <span class="token comment">// 遍历所有的节点，拼接为字符串，直到节点为 null</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result <span class="token operator">+=</span> currentNode<span class="token punctuation">.</span>data <span class="token operator">+</span> <span class="token string">'--'</span><span class="token punctuation">;</span>
      currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><h5 id="backwardstring"><a href="#backwardstring" class="header-anchor">#</a> backwardString()</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// backwardString() 链表数据从后往前以字符串形式返回</span>
  <span class="token function">backwardString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">;</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>

    <span class="token comment">// 遍历所有的节点，拼接为字符串，直到节点为 null</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result <span class="token operator">+=</span> currentNode<span class="token punctuation">.</span>data <span class="token operator">+</span> <span class="token string">'--'</span><span class="token punctuation">;</span>
      currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><h5 id="其他方法的实现"><a href="#其他方法的实现" class="header-anchor">#</a> 其他方法的实现</h5> <p>双向链表的其他方法通过继承单向链表来实现。</p> <ul><li>完整实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">DoublyLinkedList</span> <span class="token keyword">extends</span> <span class="token class-name">LinkedList</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// ------------ 链表的常见操作 ------------ //</span>
  <span class="token comment">// append(element) 往双向链表尾部追加一个新的元素</span>
  <span class="token comment">// 重写 append()</span>
  <span class="token function">append</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、创建双向链表节点</span>
    <span class="token keyword">const</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DoublyNode</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、追加元素</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// ！！跟单向链表不同，不用通过循环找到最后一个节点</span>
      <span class="token comment">// 巧妙之处</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
      newNode<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// insert(position, data) 插入元素</span>
  <span class="token comment">// 重写 insert()</span>
  <span class="token function">insert</span><span class="token punctuation">(</span><span class="token parameter">position<span class="token punctuation">,</span> element</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、position 越界判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> position <span class="token operator">&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、创建新的双向链表节点</span>
    <span class="token keyword">const</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DoublyNode</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 3、判断多种插入情况</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 在第 0 个位置插入</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">//== 巧妙之处：相处腾出 this.head 空间，留个 newNode 来赋值 ==//</span>
        newNode<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>perv <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 在最后一个位置插入</span>

      <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
      newNode<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 在 0 ~ this.length 位置中间插入</span>

      <span class="token keyword">let</span> targetIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
      <span class="token keyword">let</span> previousNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

      <span class="token comment">// 找到要插入位置的节点</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>targetIndex<span class="token operator">++</span> <span class="token operator">&lt;</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        previousNode <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>
        currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// 交换节点信息</span>
      previousNode<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
      newNode<span class="token punctuation">.</span>prev <span class="token operator">=</span> previousNode<span class="token punctuation">;</span>

      newNode<span class="token punctuation">.</span>next <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>
      currentNode<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// getData() 继承单向链表</span>
  <span class="token function">getData</span><span class="token punctuation">(</span><span class="token parameter">position</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// indexOf() 继承单向链表</span>
  <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// removeAt() 删除指定位置的节点</span>
  <span class="token comment">// 重写 removeAt()</span>
  <span class="token function">removeAt</span><span class="token punctuation">(</span><span class="token parameter">position</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、position 越界判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> position <span class="token operator">&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、根据不同情况删除元素</span>
    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 删除第一个节点的情况</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 链表内只有一个节点的情况</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 链表内有多个节点的情况</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 删除最后一个节点的情况</span>

      currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 删除 0 ~ this.length - 1 里面节点的情况</span>

      <span class="token keyword">let</span> targetIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token keyword">let</span> previousNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>targetIndex<span class="token operator">++</span> <span class="token operator">&lt;</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        previousNode <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>
        currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      previousNode<span class="token punctuation">.</span>next <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
      currentNode<span class="token punctuation">.</span>next<span class="token punctuation">.</span>perv <span class="token operator">=</span> previousNode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> currentNode<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// update(position, data) 修改指定位置的节点</span>
  <span class="token comment">// 重写 update()</span>
  <span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">position<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、删除 position 位置的节点</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeAt</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、在 position 位置插入元素</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// remove(data) 删除指定 data 所在的节点（继承单向链表）</span>
  <span class="token function">remove</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// isEmpty() 判断链表是否为空</span>
  <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// size() 获取链表的长度</span>
  <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// forwardToString() 链表数据从前往后以字符串形式返回</span>
  <span class="token function">forwardToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>

    <span class="token comment">// 遍历所有的节点，拼接为字符串，直到节点为 null</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result <span class="token operator">+=</span> currentNode<span class="token punctuation">.</span>data <span class="token operator">+</span> <span class="token string">&quot;--&quot;</span><span class="token punctuation">;</span>
      currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// backwardString() 链表数据从后往前以字符串形式返回</span>
  <span class="token function">backwardString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">;</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>

    <span class="token comment">// 遍历所有的节点，拼接为字符串，直到节点为 null</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      result <span class="token operator">+=</span> currentNode<span class="token punctuation">.</span>data <span class="token operator">+</span> <span class="token string">&quot;--&quot;</span><span class="token punctuation">;</span>
      currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="代码测试"><a href="#代码测试" class="header-anchor">#</a> 代码测试</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> doublyLinkedList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DoublyLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// append() 测试</span>
doublyLinkedList<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;ZZ&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
doublyLinkedList<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;XX&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
doublyLinkedList<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;CC&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>doublyLinkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// insert() 测试</span>
doublyLinkedList<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;00&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
doublyLinkedList<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&quot;22&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>doublyLinkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// getData() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>doublyLinkedList<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; ZZ</span>

<span class="token comment">// indexOf() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>doublyLinkedList<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">&quot;XX&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 3</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>doublyLinkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// removeAt() 测试</span>
doublyLinkedList<span class="token punctuation">.</span><span class="token function">removeAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
doublyLinkedList<span class="token punctuation">.</span><span class="token function">removeAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>doublyLinkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// update() 测试</span>
doublyLinkedList<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;111111&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>doublyLinkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// remove() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>doublyLinkedList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">&quot;111111&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>doublyLinkedList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">&quot;22222&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>doublyLinkedList<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// forwardToString() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>doublyLinkedList<span class="token punctuation">.</span><span class="token function">forwardToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// backwardString() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>doublyLinkedList<span class="token punctuation">.</span><span class="token function">backwardString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="集合"><a href="#集合" class="header-anchor">#</a> 集合</h2> <p>几乎每种编程语言中，都有集合结构。集合比较常见的实现方式是哈希表，这里使用 JavaScript 的 Object 进行封装。</p> <h3 id="集合特点"><a href="#集合特点" class="header-anchor">#</a> 集合特点</h3> <ul><li><p>集合通常是由一组<strong>无序的</strong>、<strong>不能重复的</strong>元素构成。</p></li> <li><p>数学中常指的集合中的元素是可以重复的，但是计算机中集合的元素不能重复。</p></li> <li><p>集合是特殊的数组。</p> <ul><li>特殊之处在于里面的元素没有顺序，也不能重复。</li> <li>没有顺序意味着不能通过下标值进行访问，不能重复意味着相同的对象在集合中只会存在一份。</li></ul></li></ul> <h3 id="封装集合"><a href="#封装集合" class="header-anchor">#</a> 封装集合</h3> <p>ES6 中的 <code>Set</code> 就是一个集合类，这里我们重新封装一个 <code>Set</code> 类，了解集合的底层实现。</p> <h4 id="集合常见的操作"><a href="#集合常见的操作" class="header-anchor">#</a> 集合常见的操作</h4> <ul><li><code>add(value)</code> 向集合添加一个新的项。</li> <li><code>remove(value)</code> 从集合移除一个值。</li> <li><code>has(value)</code> 如果值在集合中，返回 <code>true</code>，否则返回<code>false</code>。</li> <li><code>clear()</code> 移除集合中的所有项。</li> <li><code>size()</code> 返回集合所包含元素的数量。与数组的 <code>length</code> 属性类似。</li> <li><code>values()</code> 返回一个包含集合中所有值的数组。</li> <li>还有其他的方法，用的不多，这里不做封装。</li></ul> <h4 id="代码实现-4"><a href="#代码实现-4" class="header-anchor">#</a> 代码实现</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 集合结构的封装</span>
<span class="token keyword">class</span> <span class="token class-name">Set</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// has(value) 判断集合中是否存在 value 值，存在返回 true，否则返回 false</span>
  <span class="token function">has</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// add(value) 往集合中添加 value</span>
  <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span>value<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// remove(value) 删除集合中指定的 value</span>
  <span class="token function">remove</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果集合不存在该 value，返回 false</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// clear() 清空集合中所有 value</span>
  <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// size() 获取集合中的 value 个数</span>
  <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// values() 获取集合中所有的 value</span>
  <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="代码测试-2"><a href="#代码测试-2" class="header-anchor">#</a> 代码测试</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// add() 测试</span>
set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;zxc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; {items: {123: &quot;123&quot;, abc: &quot;abc&quot;, zxc: &quot;zxc&quot;}}</span>

<span class="token comment">// has() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">&quot;456&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; false</span>

<span class="token comment">// remove() 测试</span>
set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; {items: {123: &quot;123&quot;, zxc: &quot;zxc&quot;}}</span>

<span class="token comment">// size() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 2</span>

<span class="token comment">// values() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; [&quot;123&quot;, &quot;zxc&quot;]</span>

<span class="token comment">// clear() 测试</span>
set<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; []</span>
</code></pre></div><h3 id="集合间的操作"><a href="#集合间的操作" class="header-anchor">#</a> 集合间的操作</h3> <ul><li>并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。</li> <li>交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。</li> <li>差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。</li> <li>子集：验证一个给定集合是否是另一个集合的子集。</li></ul> <p><img src="/TechnicalNotes/assets/img/image.4utjffapm1w0.f9dca33e.png" alt="image"></p> <h4 id="并集的实现"><a href="#并集的实现" class="header-anchor">#</a> 并集的实现</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// union() 求两个集合的并集</span>
<span class="token function">union</span><span class="token punctuation">(</span><span class="token parameter">otherSet</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、创建一个新集合</span>
    <span class="token keyword">let</span> unionSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、将当前集合（this）的所有 value，添加到新集合（unionSet）中</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> value <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        unionSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3、将 otherSet 集合的所有 value，添加到新集合（unionSet）中</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> value <span class="token keyword">of</span> otherSet<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        unionSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// add() 已经有重复判断</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> unionSet<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="交集的实现"><a href="#交集的实现" class="header-anchor">#</a> 交集的实现</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// intersection() 求两个集合的交集</span>
<span class="token function">intersection</span><span class="token punctuation">(</span><span class="token parameter">otherSet</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">// 1、创建一个新集合</span>
    <span class="token keyword">let</span> intersectionSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> value <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>otherSet<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            intersectionSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> intersectionSet<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="差集的实现"><a href="#差集的实现" class="header-anchor">#</a> 差集的实现</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// difference() 差集</span>
<span class="token function">difference</span><span class="token punctuation">(</span><span class="token parameter">otherSet</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">// 1、创建一个新集合</span>
    <span class="token keyword">let</span> differenceSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，不存在的即为差集</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> value <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>otherSet<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            differenceSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> differenceSet<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="子集的实现"><a href="#子集的实现" class="header-anchor">#</a> 子集的实现</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// subset() 子集</span>
<span class="token function">subset</span><span class="token punctuation">(</span><span class="token parameter">otherSet</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">// 从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，有不存在的返回 false</span>
    <span class="token comment">// 遍历完所有的，返回 true</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> value <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>otherSet<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="集合的完整实现"><a href="#集合的完整实现" class="header-anchor">#</a> 集合的完整实现</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 集合结构的封装</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Set</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// has(value) 判断集合中是否存在 value 值，存在返回 true，否则返回 false</span>
  <span class="token function">has</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// add(value) 往集合中添加 value</span>
  <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span>value<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// remove(value) 删除集合中指定的 value</span>
  <span class="token function">remove</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果集合不存在该 value，返回 false</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// clear() 清空集合中所有 value</span>
  <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// size() 获取集合中的 value 个数</span>
  <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// values() 获取集合中所有的 value</span>
  <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// ------- 集合间的操作 ------- //</span>
  <span class="token comment">// union() 求两个集合的并集</span>
  <span class="token function">union</span><span class="token punctuation">(</span><span class="token parameter">otherSet</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、创建一个新集合</span>
    <span class="token keyword">let</span> unionSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、将当前集合（this）的所有 value，添加到新集合（unionSet）中</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> value <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      unionSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3、将 otherSet 集合的所有 value，添加到新集合（unionSet）中</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> value <span class="token keyword">of</span> otherSet<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      unionSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// add() 已经有重复判断</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> unionSet<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// intersection() 求两个集合的交集</span>
  <span class="token function">intersection</span><span class="token punctuation">(</span><span class="token parameter">otherSet</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、创建一个新集合</span>
    <span class="token keyword">let</span> intersectionSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> value <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>otherSet<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        intersectionSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> intersectionSet<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// difference() 差集</span>
  <span class="token function">difference</span><span class="token punctuation">(</span><span class="token parameter">otherSet</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、创建一个新集合</span>
    <span class="token keyword">let</span> differenceSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，不存在的即为差集</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> value <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>otherSet<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        differenceSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> differenceSet<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// subset() 子集</span>
  <span class="token function">subset</span><span class="token punctuation">(</span><span class="token parameter">otherSet</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 从当前集合中取出每一个 value，判断是否在 otherSet 集合中存在，有不存在的返回 false</span>
    <span class="token comment">// 遍历完所有的，返回 true</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> value <span class="token keyword">of</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>otherSet<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="字典"><a href="#字典" class="header-anchor">#</a> 字典</h2> <h3 id="字典特点"><a href="#字典特点" class="header-anchor">#</a> 字典特点</h3> <ul><li>字典存储的是<strong>键值对</strong>，主要特点是<strong>一一对应</strong>。</li> <li>比如保存一个人的信息
<ul><li>数组形式：<code>[19，&quot;Tom&quot;, 1.65]</code>，可通过下标值取出信息。</li> <li>字典形式：<code>{&quot;age&quot;: 19, &quot;name&quot;: &quot;Tom&quot;, &quot;height&quot;: 165}</code>，可以通过 <code>key</code> 取出 <code>value</code>。</li></ul></li> <li>此外，在字典中 key 是不能重复且无序的，而 Value 可以重复。</li></ul> <h3 id="字典和映射的关系"><a href="#字典和映射的关系" class="header-anchor">#</a> 字典和映射的关系</h3> <ul><li>有些编程语言中称这种映射关系为<strong>字典</strong>，如 Swift 中的 <code>Dictonary</code>，Python 中的 <code>dict</code>。</li> <li>有些编程语言中称这种映射关系为 <strong>Map</strong>，比如 Java 中的 <code>HashMap</code> 和 <code>TreeMap</code> 等。</li></ul> <h3 id="字典常见的操作"><a href="#字典常见的操作" class="header-anchor">#</a> 字典常见的操作</h3> <ul><li><code>set(key,value)</code> 向字典中添加新元素。</li> <li><code>remove(key)</code> 通过使用键值来从字典中移除键值对应的数据值。</li> <li><code>has(key)</code> 如果某个键值存在于这个字典中，则返回 <code>true</code>，反之则返回 <code>false</code>。</li> <li><code>get(key)</code> 通过键值查找特定的数值并返回。</li> <li><code>clear()</code> 将这个字典中的所有元素全部删除。</li> <li><code>size()</code> 返回字典所包含元素的数量。与数组的 <code>length</code> 属性类似。</li> <li><code>keys()</code> 将字典所包含的所有键名以数组形式返回。</li> <li><code>values()</code> 将字典所包含的所有数值以数组形式返回。</li></ul> <h3 id="字典封装"><a href="#字典封装" class="header-anchor">#</a> 字典封装</h3> <h4 id="代码实现-5"><a href="#代码实现-5" class="header-anchor">#</a> 代码实现</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 字典结构的封装</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Map</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// has(key) 判断字典中是否存在某个 key</span>
  <span class="token function">has</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// set(key, value) 在字典中添加键值对</span>
  <span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// remove(key) 在字典中删除指定的 key</span>
  <span class="token function">remove</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果集合不存在该 key，返回 false</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// get(key) 获取指定 key 的 value，如果没有，返回 undefined</span>
  <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 获取所有的 key</span>
  <span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 获取所有的 value</span>
  <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// size() 获取字典中的键值对个数</span>
  <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// clear() 清空字典中所有的键值对</span>
  <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="代码测试-3"><a href="#代码测试-3" class="header-anchor">#</a> 代码测试</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// set() 测试</span>
map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;XPoet&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;age&quot;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;email&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;i@xpoet.cn&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {items: {name: &quot;XPoet&quot;, age: 18, email: &quot;i@xpoet.cn&quot;}}</span>

<span class="token comment">// has() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span><span class="token string">&quot;address&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; false</span>

<span class="token comment">// remove() 测试</span>
map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {age: 18, email: &quot;i@xpoet.cn&quot;}</span>

<span class="token comment">// get() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;age&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 18</span>

<span class="token comment">// keys() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; [&quot;age&quot;, &quot;email&quot;]</span>

<span class="token comment">// values() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; [18, &quot;i@xpoet.cn&quot;]</span>

<span class="token comment">// size() 测试</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 2</span>
</code></pre></div><h2 id="哈希表"><a href="#哈希表" class="header-anchor">#</a> 哈希表</h2> <p>哈希表是一种非常重要的数据结构，几乎所有的编程语言都直接或者间接应用这种数据结构。</p> <p>哈希表通常是基于数组实现的，但是相对于数组，它存在更多优势：</p> <ul><li>哈希表可以提供非常快速的 <strong>插入-删除-查找</strong> 操作。</li> <li>无论多少数据，插入和删除值都只需接近常量的时间，即 <strong>O(1)</strong> 的时间复杂度。实际上，只需要几个机器指令即可完成。</li> <li>哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。</li> <li>哈希表相对于树来说编码要简单得多。</li></ul> <p>哈希表同样存在不足之处：</p> <ul><li>哈希表中的数据是没有顺序的，所以不能以一种固定的方式（比如从小到大 ）来遍历其中的元素。</li> <li>通常情况下，哈希表中的 <code>key</code> 是不允许重复的，不能放置相同的 <code>key</code>，用于保存不同的元素。</li></ul> <p>哈希表是什么？</p> <ul><li>哈希表并不好理解，不像数组、链表和树等可通过图形的形式表示其结构和原理。</li> <li>哈希表的结构就是数组，但它<strong>神奇之处在于对下标值的一种变换</strong>，这种变换我们可以称之为<strong>哈希函数</strong>，通过哈希函数可以获取 HashCode。</li></ul> <p>通过以下案例了解哈希表：</p> <ul><li><p>案例一：公司想要存储 1000 个人的信息，每一个工号对应一个员工的信息。若使用数组，增删数据时比较麻烦；使用链表，获取数据时比较麻烦。有没有一种数据结构，能把某一员工的姓名转换为它对应的工号，再根据工号查找该员工的完整信息呢？没错此时就可以使用哈希表的哈希函数来实现。</p></li> <li><p>案例二：存储联系人和对应的电话号码：当要查找张三（比如）的号码时，若使用数组：由于不知道存储张三数据对象的下标值，所以查找起来十分麻烦，使用链表时也同样麻烦。而使用哈希表就能通过哈希函数把张三这个名称转换为它对应的下标值，再通过下标值查找效率就非常高了。</p></li></ul> <p>也就是说：哈希表最后还是基于数据来实现的，只不过哈希表能够通过哈希函数把字符串转化为对应的下标值，建立字符串和下标值的映射关系。</p> <h3 id="认识哈希化"><a href="#认识哈希化" class="header-anchor">#</a> 认识哈希化</h3> <p>为了把字符串转化为对应的下标值，需要有一套编码系统，为了方便理解我们创建这样一套编码系统：比如 a 为 1，b 为 2，c 为 3，以此类推 z 为 26，空格为 27（不考虑大写情况）。</p> <p>有了编码系统后，将字母转化为数字也有很多种方案：</p> <ul><li>方案一：数字相加。</li></ul> <p>例如 cats 转化为数字：<code>3 + 1 + 20 + 19 = 43</code>，那么就把 43 作为 cats 单词的下标值储存在数组中；</p> <p>但是这种方式会存在这样的问题：很多的单词按照该方式转化为数字后都是 43，比如 was。而在数组中一个下标值只能储存一个数据，所以该方式不合理。</p> <ul><li>方案二：幂的连乘。</li></ul> <p>我们平时使用的大于 10 的数字，就是用幂的连乘来表示它的唯一性的。
比如： <code>6543 = 6 * 10^3 + 5 * 10^2 + 4 * 10 + 3</code>；这样单词也可以用该种方式来表示：<code>cats = 3 * 27^3 + 1 * 27^2 + 20 * 27 + 17 = 60337</code>。</p> <p>虽然该方式可以保证字符的唯一性，但是如果是较长的字符（如 aaaaaaaaaa）所表示的数字就非常大，此时要求很大容量的数组，然而其中却有许多下标值指向的是无效的数据（比如不存在 zxcvvv 这样的单词），造成了数组空间的浪费。</p> <p>两种方案总结：</p> <ul><li>第一种方案（让数字相加求和）产生的数组下标太少。</li> <li>第二种方案（与 27 的幂相乘求和）产生的数组下标又太多。</li></ul> <p>现在需要一种压缩方法，把幂的连乘方案系统中得到的<strong>巨大整数范围压缩到可接受的数组范围中</strong>。可以通过<strong>取余</strong>操作来实现。虽然取余操作得到的结构也有可能重复，但是可以通过其他方式解决。</p> <h3 id="哈希表的一些概念"><a href="#哈希表的一些概念" class="header-anchor">#</a> 哈希表的一些概念</h3> <ul><li><p><strong>哈希化</strong></p> <p>将<strong>大数字</strong>转化成<strong>数组范围内下标</strong>的过程，称之为哈希化。</p></li> <li><p><strong>哈希函数</strong></p> <p>我们通常会将单词转化成大数字，把大数字进行哈希化的代码实现放在一个函数中，该函数就称为哈希函数。</p></li> <li><p><strong>哈希表</strong></p> <p>对最终数据插入的数组进行整个结构的封装，得到的就是哈希表。</p></li></ul> <h3 id="地址的冲突"><a href="#地址的冲突" class="header-anchor">#</a> 地址的冲突</h3> <p>在实际中，经过哈希函数哈希化过后得到的下标值可能有重复，这种情况称为冲突，冲突是不可避免的，我们只能解决冲突。</p> <p>解决冲突常见的两种方案：链地址法（拉链法）和开放地址法。</p> <h4 id="链地址法-拉链法"><a href="#链地址法-拉链法" class="header-anchor">#</a> 链地址法（拉链法）</h4> <p>如下图所示，我们将每一个数字都对 10 进行取余操作，则余数的范围 0~9 作为数组的下标值。并且，数组每一个下标值对应的位置存储的不再是一个数字了，而是存储由经过取余操作后得到相同余数的数字组成的数组或链表。</p> <p><img src="https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.5irlba213e00.png" alt="image"></p> <p>这样可以根据下标值获取到整个数组或链表，之后继续在数组或链表中查找就可以了。而且，产生冲突的元素一般不会太多。</p> <p>总结：链地址法解决冲突的办法是每个数组单元中存储的不再是单个数据，而是一条链条，这条链条常使用的数据结构为数组或链表，两种数据结构查找的效率相当（因为链条的元素一般不会太多）。</p> <h4 id="开放地址法"><a href="#开放地址法" class="header-anchor">#</a> 开放地址法</h4> <p>开放地址法的主要工作方式是寻找空白的单元格来放置冲突的数据项。</p> <p><img src="https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.52qzixg5w4s0.png" alt="image"></p> <p>根据探测空白单元格位置方式的不同，可分为三种方法：</p> <ul><li>线性探测</li> <li>二次探测</li> <li>再哈希法</li></ul> <h5 id="线性探测"><a href="#线性探测" class="header-anchor">#</a> 线性探测</h5> <ul><li>当插入 13 时：</li></ul> <p>经过哈希化（对 10 取余）之后得到的下标值 index=3，但是该位置已经放置了数据 33。而线性探测就是从 index 位置+1 开始向后一个一个来查找合适的位置来放置 13，所谓合适的位置指的是空的位置，如上图中 index=4 的位置就是合适的位置。</p> <ul><li><p>当查询 13 时：</p> <ul><li>首先 13 经过哈希化得到 index=3，如果 index=3 的位置存放的数据与需要查询的数据 13 相同，就直接返回；
不相同时，则线性查找，从 index+1 位置开始一个一个位置地查找数据 13。</li> <li>查询过程中不会遍历整个哈希表，只要查询到空位置，就停止，因为插入 13 时不会跳过空位置去插入其他位置。</li></ul></li> <li><p>当删除 13 时：</p> <ul><li>删除操作和上述两种情况类似，但需要注意的是，删除一个数据项时，不能将该位置下标的内容设置为 null，否则会影响到之后其他的查询操作，因为一遇到为 null 的位置就会停止查找。</li> <li>通常删除一个位置的数据项时，我们可以将它进行特殊处理（比如设置为-1），这样在查找时遇到-1 就知道要继续查找。</li></ul></li></ul> <p>线性探测存在的问题：</p> <ul><li><p>线性探测存在一个比较严重的问题，就是聚集。</p></li> <li><p>如哈希表中还没插入任何元素时，插入 23、24、25、26、27，这就意味着下标值为 3、4、5、6、7 的位置都放置了数据，这种一连串填充单元就称为聚集。</p></li> <li><p>聚集会影响哈希表的性能，无论是插入/查询/删除都会影响。</p></li> <li><p>比如插入 13 时就会发现，连续的单元 3~7 都不允许插入数据，并且在插入的过程中需要经历多次这种情况。二次探测法可以解决该问题。</p></li></ul> <p><img src="https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.47l36021j8m0.png" alt="image"></p> <h5 id="二次探测"><a href="#二次探测" class="header-anchor">#</a> 二次探测</h5> <p>上文所说的线性探测存在的问题：</p> <ul><li><p>如果之前的数据是连续插入的，那么新插入的一个数据可能需要探测很长的距离；</p> <p>二次探测是在线性探测的基础上进行了优化：</p></li> <li><p>线性探测：我们可以看成是步长为 1 的探测，比如从下表值 x 开始，那么线性探测就是按照下标值：x+1、x+2、x+3 等依次探测；</p></li> <li><p>二次探测：对步长进行了优化，比如从下标值 x 开始探测：x+1^2^、x+2^2^、x+3^3^ 。这样一次性探测比较长的距离，避免了数据聚集带来的影响。</p></li> <li><p>二次探测存在的问题：</p> <p>当插入数据分布性较大的一组数据时，比如：13-163-63-3-213，这种情况会造成步长不一的一种聚集（虽然这种情况出现的概率较线性探测的聚集要小），同样会影响性能。</p></li></ul> <h5 id="再哈希法"><a href="#再哈希法" class="header-anchor">#</a> 再哈希法</h5> <p>在开放地址法中寻找空白单元格的最好的解决方式为再哈希化。</p> <ul><li>二次探测的步长是固定的：1，4，9，16 依次类推。</li> <li>现在需要一种方法：产生一种依赖关键字(数据)的探测序列，而不是每个关键字探测步长都一样。</li> <li>这样，不同的关键字即使映射到相同的数组下标，也可以使用不同的探测序列。</li> <li>再哈希法的做法为：把关键字用另一个哈希函数，再做一次哈希化，用这次哈希化的结果作为该关键字的步长。</li></ul> <p>第二次哈希化需要满足以下两点：</p> <ul><li>和第一个哈希函数不同，不然哈希化后的结果仍是原来位置；</li> <li>不能输出为 0，否则每次探测都是原地踏步的死循环；</li></ul> <p>优秀的哈希函数：</p> <ul><li>stepSize = constant - （key % constant）；</li> <li>其中 constant 是质数，且小于数组的容量；</li> <li>例如：stepSize = 5 - （key % 5），满足需求，并且结果不可能为 0；</li></ul> <p>哈希化的效率</p> <p>哈希表中执行插入和搜索操作效率是非常高的。</p> <ul><li>如果没有发生冲突，那么效率就会更高；</li> <li>如果发生冲突，存取时间就依赖后来的探测长度；</li> <li>平均探测长度以及平均存取时间，取决于填装因子，随着填装因子变大，探测长度会越来越长。</li></ul> <h4 id="装填因子"><a href="#装填因子" class="header-anchor">#</a> 装填因子</h4> <ul><li>装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值；</li> <li>装填因子 = 总数据项 / 哈希表长度；</li> <li>开放地址法的装填因子最大为 1，因为只有空白的单元才能放入元素；</li> <li>链地址法的装填因子可以大于 1，因为只要愿意，拉链法可以无限延伸下去；</li></ul> <h4 id="不同探测方式性能的比较"><a href="#不同探测方式性能的比较" class="header-anchor">#</a> 不同探测方式性能的比较</h4> <ul><li><p>线性探测</p> <p>可以看到，随着装填因子的增大，平均探测长度呈指数形式增长，性能较差。实际情况中，最好的装填因子取决于存储效率和速度之间的平衡，随着装填因子变小，存储效率下降，而速度上升。</p> <p><img src="https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.2pcxv1f720o0.png" alt="image"></p></li> <li><p>二次探测和再哈希化的性能</p> <p>二次探测和再哈希法性能相当，它们的性能比线性探测略好。由下图可知，随着装填因子的变大，平均探测长度呈指数形式增长，需要探测的次数也呈指数形式增长，性能不高。</p> <p><img src="https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.f06tizypf6g.png" alt="image"></p></li> <li><p>链地址法的性能</p> <p>可以看到随着装填因子的增加，平均探测长度呈线性增长，较为平缓。在开发中使用链地址法较多，比如 Java 中的 HashMap 中使用的就是链地址法。</p> <p><img src="https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.45s3ntwwjia0.png" alt="image"></p></li></ul> <h3 id="哈希函数"><a href="#哈希函数" class="header-anchor">#</a> 哈希函数</h3> <p>哈希表的优势在于它的速度，所以哈希函数不能采用消耗性能较高的复杂算法。提高速度的一个方法是在哈希函数中尽量减少乘法和除法。</p> <p>性能高的哈希函数应具备以下两个优点：</p> <ul><li>快速的计算；</li> <li>均匀的分布；</li></ul> <h4 id="快速计算"><a href="#快速计算" class="header-anchor">#</a> 快速计算</h4> <p>霍纳法则：在中国霍纳法则也叫做秦久韶算法，具体算法为：</p> <p><img src="https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.4kz61djvvau0.png" alt="image"></p> <p>求多项式的值时，首先计算最内层括号内一次多项式的值，然后由内向外逐层计算一次多项式的值。这种算法把求 n 次多项式 f(x)的值就转化为求 n 个一次多项式的值。</p> <ul><li><p>变换之前：</p> <ul><li>乘法次数：n(n+1)/2 次；</li> <li>加法次数：n 次；</li></ul></li> <li><p>变换之后：</p> <ul><li>乘法次数：n 次；</li> <li>加法次数：n 次；</li></ul></li></ul> <p>如果使用大 O 表示时间复杂度的话，直接从变换前的 O(N^2)降到了 O(N)。</p> <h4 id="均匀分布"><a href="#均匀分布" class="header-anchor">#</a> 均匀分布</h4> <p>在设计哈希表时，我们已经有办法处理映射到相同下标值的情况：链地址法或者开放地址法。但是，为了提供效率，最好的情况还是让数据在哈希表中均匀分布。因此，我们需要在使用常量的地方，尽量使用质数。比如：哈希表的长度、N 次幂的底数等。</p> <p>Java 中的 HashMap 采用的是链地址法，哈希化采用的是公式为：index = HashCode(key) &amp; (Length-1) 即将数据化为二进制进行与运算，而不是取余运算。这样计算机直接运算二进制数据，效率更高。但是 JavaScript 在进行较大数据的与运算时会出现问题，所以我们使用 JavaScript 实现哈希化时采用取余运算。</p> <h2 id="封装哈希表"><a href="#封装哈希表" class="header-anchor">#</a> 封装哈希表</h2> <h3 id="哈希表常见操作"><a href="#哈希表常见操作" class="header-anchor">#</a> 哈希表常见操作</h3> <ul><li><code>put(key, value)</code> 插入或修改操作。</li> <li><code>get(key)</code> 获取哈希表中特定位置的元素。</li> <li><code>remove(key)</code> 删除哈希表中特定位置的元素。</li> <li><code>isEmpty()</code> 如果哈希表中不包含任何元素，返回 <code>trun</code>，如果哈希表长度大于 0 则返回 <code>false</code>。</li> <li><code>size()</code> 返回哈希表包含的元素个数。</li> <li><code>resize(value)</code> 对哈希表进行扩容操作。</li></ul> <h3 id="哈希函数的简单实现"><a href="#哈希函数的简单实现" class="header-anchor">#</a> 哈希函数的简单实现</h3> <p>首先使用霍纳法则计算 hashCode 的值，通过取余操作实现哈希化，此处先简单地指定数组的大小。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">hashFn</span><span class="token punctuation">(</span><span class="token parameter">string<span class="token punctuation">,</span> limit <span class="token operator">=</span> <span class="token number">7</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token comment">// 自己采用的一个质数（无强制要求，质数即可）</span>
  <span class="token keyword">const</span> <span class="token constant">PRIME</span> <span class="token operator">=</span> <span class="token number">31</span><span class="token punctuation">;</span>

  <span class="token comment">// 1、定义存储 hashCode 的变量</span>
  <span class="token keyword">let</span> hashCode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token comment">// 2、使用霍纳法则（秦九韶算法），计算 hashCode 的值</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> string<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    hashCode <span class="token operator">=</span> <span class="token constant">PRIME</span> <span class="token operator">*</span> hashCode <span class="token operator">+</span> item<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 3、对 hashCode 取余，并返回</span>
  <span class="token keyword">return</span> hashCode <span class="token operator">%</span> limit<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>哈希函数测试</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">hashFn</span><span class="token punctuation">(</span><span class="token string">&quot;123&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 5</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">hashFn</span><span class="token punctuation">(</span><span class="token string">&quot;abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//--&gt; 6</span>
</code></pre></div><h3 id="哈希表的实现"><a href="#哈希表的实现" class="header-anchor">#</a> 哈希表的实现</h3> <h4 id="创建哈希表类"><a href="#创建哈希表类" class="header-anchor">#</a> 创建哈希表类</h4> <p>封装的哈希表的数据结构模型：</p> <p><img src="https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.7h3eahcbrvs0.png" alt="image"></p> <p>首先创建哈希表类 HashTable，并添加必要的属性和上面实现的哈希函数，再进行其他方法的实现。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">HashTable</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>storage <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 哈希表存储数据的变量</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 当前存放的元素个数</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token comment">// 哈希表长度（初始设为质数 7）</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="put-key-value"><a href="#put-key-value" class="header-anchor">#</a> put(key,value)</h4> <p>哈希表的插入和修改操作是同一个函数：因为，当使用者传入一个 <code>[key, value]</code> 时，如果原来不存在该 key，那么就是插入操作，如果原来已经存在该 key，那么就是修改操作。</p> <p><img src="https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.2a81gwdznn8k.png" alt="image"></p> <p>实现思路：</p> <ul><li>首先，根据 key 获取索引值 index，目的为将数据插入到 storage 的对应位置；</li> <li>然后，根据索引值取出 bucket，如果 bucket 不存在，先创建 bucket，随后放置在该索引值的位置；</li> <li>接着，判断新增还是修改原来的值。如果已经有值了，就修改该值；如果没有，就执行后续操作。</li> <li>最后，进行新增数据操作。</li></ul> <p>代码实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// put(key, value) 往哈希表里添加数据</span>
<span class="token function">put</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token comment">// 1、根据 key 获取要映射到 storage 里面的 index（通过哈希函数获取）</span>
  <span class="token keyword">const</span> index <span class="token operator">=</span> <span class="token function">hashFn</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>limit<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 2、根据 index 取出对应的 bucket</span>
  <span class="token keyword">let</span> bucket <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>storage<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token comment">// 3、判断是否存在 bucket</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>bucket <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bucket <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 不存在则创建</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>storage<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 4、判断是插入数据操作还是修改数据操作</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucket<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> tuple <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// tuple 的格式：[key, value]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tuple<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果 key 相等，则修改数据</span>
      tuple<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 修改完 tuple 里数据，return 终止不再往下执行。</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 5、bucket 新增数据</span>
  bucket<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bucket 存储元组 tuple，格式为 [key, value]</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>

  <span class="token comment">// 判断哈希表是否要扩容，若装填因子 &gt; 0.75，则扩容</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPrime</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><h4 id="get-key"><a href="#get-key" class="header-anchor">#</a> get(key)</h4> <p>实现思路：</p> <ul><li>首先，根据 key 通过哈希函数获取它在 <code>storage</code> 中对应的索引值 <code>index</code>。</li> <li>然后，根据索引值获取对应的 <code>bucket</code>。</li> <li>接着，判断获取到的 <code>bucket</code> 是否为 <code>null</code>，如果为 <code>null</code>，直接返回 <code>null</code>。</li> <li>随后，线性遍历 <code>bucket</code> 中每一个 <code>key</code> 是否等于传入的 <code>key</code>。如果等于，直接返回对应的 <code>value</code>。</li> <li>最后，遍历完 <code>bucket</code> 后，仍然没有找到对应的 <code>key</code>，直接 <code>return null</code> 即可。</li></ul> <p>代码实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 根据 get(key) 获取 value</span>
<span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">const</span> index <span class="token operator">=</span> <span class="token function">hashFn</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>limit<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> bucket <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>storage<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>bucket <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> tuple <span class="token keyword">of</span> bucket<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tuple<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> tuple<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="remove-key"><a href="#remove-key" class="header-anchor">#</a> remove(key)</h4> <p>实现思路：</p> <ul><li>首先，根据 key 通过哈希函数获取它在 <code>storage</code> 中对应的索引值 <code>index</code>。</li> <li>然后，根据索引值获取对应的 <code>bucket</code>。</li> <li>接着，判断获取到的 <code>bucket</code> 是否为 <code>null</code>，如果为 <code>null</code>，直接返回 <code>null</code>。</li> <li>随后，线性查找 <code>bucket</code>，寻找对应的数据，并且删除。</li> <li>最后，依然没有找到，返回 <code>null</code>。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// remove(key) 删除指定 key 的数据</span>
<span class="token function">remove</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">const</span> index <span class="token operator">=</span> <span class="token function">hashFn</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>limit<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> bucket <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>storage<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>bucket <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 遍历 bucket，找到对应位置的 tuple，将其删除</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">=</span> bucket<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> tuple <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tuple<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      bucket<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除对应位置的数组项</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">;</span>

      <span class="token comment">// 根据装填因子的大小，判断是否要进行哈希表压缩</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">&gt;</span> <span class="token number">7</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>minLoadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPrime</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      <span class="token keyword">return</span> tuple<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><h4 id="isempty"><a href="#isempty" class="header-anchor">#</a> isEmpty()</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="size"><a href="#size" class="header-anchor">#</a> size()</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="哈希表的扩容与压缩"><a href="#哈希表的扩容与压缩" class="header-anchor">#</a> 哈希表的扩容与压缩</h2> <p>为什么需要扩容？</p> <ul><li><p>前面我们在哈希表中使用的是长度为 7 的数组，由于使用的是链地址法，装填因子(loadFactor)可以大于 1，所以这个哈希表可以无限制地插入新数据。</p></li> <li><p>但是，随着数据量的增多，storage 中每一个 <code>index</code> 对应的 <code>bucket</code> 数组（链表）就会越来越长，这就会造成哈希表效率的降低。</p></li></ul> <p>什么情况下需要扩容？</p> <ul><li>常见的情况是 <code>loadFactor &gt; 0.75</code> 的时候进行扩容。</li></ul> <p>如何进行扩容？</p> <ul><li>简单的扩容可以直接扩大两倍（关于质数，之后讨论）。</li> <li>扩容之后所有的数据项都要进行同步修改。</li></ul> <p>实现思路：</p> <ul><li>首先，定义一个变量，比如 oldStorage 指向原来的 <code>storage</code>。</li> <li>然后，创建一个新的容量更大的数组，让 <code>this.storage</code> 指向它。</li> <li>最后，将 oldStorage 中的每一个 bucket 中的每一个数据取出来依次添加到 <code>this.storage</code> 指向的新数组中。</li></ul> <p><img src="https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.7xrayvjwh2w.png" alt="image"></p> <h3 id="resize-的实现"><a href="#resize-的实现" class="header-anchor">#</a> resize() 的实现</h3> <p>装填因子 = 哈希表中数据 / 哈希表长度，即 <code>loadFactor = count / HashTable.length</code>。</p> <p>resize 方法，既可以实现哈希表的扩容，也可以实现哈希表容量的压缩。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 重新调整哈希表大小，扩容或压缩</span>
<span class="token function">resize</span><span class="token punctuation">(</span><span class="token parameter">newLimit</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token comment">// 1、保存旧的 storage 数组内容</span>
  <span class="token keyword">const</span> oldStorage <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>storage<span class="token punctuation">;</span>

  <span class="token comment">// 2、重置所有属性</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>storage <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">=</span> newLimit<span class="token punctuation">;</span>

  <span class="token comment">// 3、遍历 oldStorage，取出所有数据，重新 put 到 this.storage</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> bucket <span class="token keyword">of</span> oldStorage<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bucket<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> b <span class="token keyword">of</span> bucket<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>通常情况下当装填因子 <code>laodFactor &gt; 0.75</code> 时，对哈希表进行扩容。在哈希表中的添加方法（push 方法）中添加如下代码，判断是否需要调用扩容函数进行扩容。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 判断哈希表是否要扩容，若装填因子 &gt; 0.75，则扩容</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPrime</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <ul><li><p>当装填因子 <code>laodFactor &lt; 0.25</code> 时，对哈希表容量进行压缩。在哈希表中的删除方法（remove 方法）中添加如下代码，判断是否需要调用扩容函数进行压缩。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 根据装填因子的大小，判断是否要进行哈希表压缩</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">&gt;</span> <span class="token number">7</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>minLoadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPrime</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h3 id="选择质数作为哈希表容量"><a href="#选择质数作为哈希表容量" class="header-anchor">#</a> 选择质数作为哈希表容量</h3> <h4 id="质数判断"><a href="#质数判断" class="header-anchor">#</a> 质数判断</h4> <blockquote><p>1 不是质数</p></blockquote> <ul><li><p>方法一：针对质数的特点：只能被 1 和 number 整除，不能被 2 ~ (number-1)整除。遍历 2 ~ (num-1) 。</p> <p>这种方法虽然能实现质数的判断，但是效率不高。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isPrime</span><span class="token punctuation">(</span><span class="token parameter">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> number<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">%</span> i <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>方法二：只需要遍历 2 ~ num 的平方根即可。该方法性能较好。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isPrime</span><span class="token punctuation">(</span><span class="token parameter">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token operator">||</span> number <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> temp <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> temp<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>number <span class="token operator">%</span> i <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h4 id="实现扩容或压缩后的哈希表容量为质数"><a href="#实现扩容或压缩后的哈希表容量为质数" class="header-anchor">#</a> 实现扩容或压缩后的哈希表容量为质数</h4> <p>实现思路：</p> <p>2 倍扩容或压缩之后，通过循环调用 <code>isPrime</code> 判断得到的容量是否为质数，不是则+1，直到是为止。比如原长度：7，2 倍扩容后长度为 14，14 不是质数，<code>14 + 1 = 15</code> 不是质数，<code>15 + 1 = 16</code> 不是质数，<code>16 + 1 = 17</code> 是质数，停止循环，由此得到质数 17。</p> <ul><li><p>第一步：首先需要为 HashTable 类添加判断质数的 <code>isPrime</code> 方法和获取质数的 <code>getPrime</code> 方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// getPrime(number) 根据传入的 number 获取最临近的质数</span>
<span class="token function">getPrime</span><span class="token punctuation">(</span><span class="token parameter">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isPrime</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    number<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> number<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>修改添加元素的 <code>put</code> 方法和删除元素的 <code>remove</code> 方法中关于数组扩容的相关操作：</p> <p>在 <code>put</code> 方法中添加如下代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 判断哈希表是否要扩容，若装填因子 &gt; 0.75，则扩容</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPrime</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 <code>remove</code> 方法中添加如下代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 根据装填因子的大小，判断是否要进行哈希表压缩</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">&gt;</span> <span class="token number">7</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>minLoadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPrime</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="哈希表完整实现"><a href="#哈希表完整实现" class="header-anchor">#</a> 哈希表完整实现</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">HashTable</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>storage <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 哈希表存储数据的变量</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 当前存放的元素个数</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token comment">// 哈希表长度（初始设为质数 7）</span>

    <span class="token comment">// 装填因子(已有个数/总个数)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> <span class="token number">0.75</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>minLoadFactor <span class="token operator">=</span> <span class="token number">0.25</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// getPrime(number) 根据传入的 number 获取最临近的质数</span>
  <span class="token function">getPrime</span><span class="token punctuation">(</span><span class="token parameter">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isPrime</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      number<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> number<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// put(key, value) 往哈希表里添加数据</span>
  <span class="token function">put</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、根据 key 获取要映射到 storage 里面的 index（通过哈希函数获取）</span>
    <span class="token keyword">const</span> index <span class="token operator">=</span> <span class="token function">hashFn</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>limit<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、根据 index 取出对应的 bucket</span>
    <span class="token keyword">let</span> bucket <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>storage<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment">// 3、判断是否存在 bucket</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bucket <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      bucket <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 不存在则创建</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>storage<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> bucket<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 4、判断是插入数据操作还是修改数据操作</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucket<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> tuple <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// tuple 的格式：[key, value]</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>tuple<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果 key 相等，则修改数据</span>
        tuple<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 修改完 tuple 里数据，return 终止，不再往下执行。</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 5、bucket 新增数据</span>
    bucket<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bucket 存储元组 tuple，格式为 [key, value]</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>

    <span class="token comment">// 判断哈希表是否要扩容，若装填因子 &gt; 0.75，则扩容</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPrime</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 根据 get(key) 获取 value</span>
  <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> index <span class="token operator">=</span> <span class="token function">hashFn</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>limit<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> bucket <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>storage<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>bucket <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> tuple <span class="token keyword">of</span> bucket<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>tuple<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> tuple<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// remove(key) 删除指定 key 的数据</span>
  <span class="token function">remove</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> index <span class="token operator">=</span> <span class="token function">hashFn</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>limit<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> bucket <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>storage<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>bucket <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 遍历 bucket，找到对应位置的 tuple，将其删除</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">=</span> bucket<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> tuple <span class="token operator">=</span> bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>tuple<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        bucket<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除对应位置的数组项</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">--</span><span class="token punctuation">;</span>

        <span class="token comment">// 根据装填因子的大小，判断是否要进行哈希表压缩</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">&gt;</span> <span class="token number">7</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">/</span> <span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>minLoadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getPrime</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> tuple<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 重新调整哈希表大小，扩容或压缩</span>
  <span class="token function">resize</span><span class="token punctuation">(</span><span class="token parameter">newLimit</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1、保存旧的 storage 数组内容</span>
    <span class="token keyword">const</span> oldStorage <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>storage<span class="token punctuation">;</span>

    <span class="token comment">// 2、重置所有属性</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>storage <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">=</span> newLimit<span class="token punctuation">;</span>

    <span class="token comment">// 3、遍历 oldStorage，取出所有数据，重新 put 到 this.storage</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> bucket <span class="token keyword">of</span> oldStorage<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>bucket<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> b <span class="token keyword">of</span> bucket<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="树结构"><a href="#树结构" class="header-anchor">#</a> 树结构</h2> <h3 id="什么是树"><a href="#什么是树" class="header-anchor">#</a> 什么是树？</h3> <h4 id="真实的树"><a href="#真实的树" class="header-anchor">#</a> 真实的树：</h4> <p><img src="/TechnicalNotes/assets/img/image.6pnzzxbinjs0.eb6d59c8.png" alt="image"></p> <h4 id="树的特点"><a href="#树的特点" class="header-anchor">#</a> 树的特点：</h4> <ul><li>树一般都有一个根，连接着根的是树干；</li> <li>树干会发生分叉，形成许多树枝，树枝会继续分化成更小的树枝；</li> <li>树枝的最后是叶子；</li></ul> <p>现实生活中很多结构都是树的抽象，模拟的树结构相当于旋转 <code>180°</code> 的树。</p> <p><img src="/TechnicalNotes/assets/img/image.4mrygbtnd6w0.dd74401d.png" alt="image"></p> <h4 id="树结构对比于数组-链表-哈希表有哪些优势呢"><a href="#树结构对比于数组-链表-哈希表有哪些优势呢" class="header-anchor">#</a> 树结构对比于数组/链表/哈希表有哪些优势呢？</h4> <p>数组：</p> <ul><li>优点：可以通过下标值访问，效率高；</li> <li>缺点：查找数据时需要先对数据进行排序，生成有序数组，才能提高查找效率；并且在插入和删除元素时，需要大量的位移操作；</li></ul> <p>链表：</p> <ul><li>优点：数据的插入和删除操作效率都很高；</li> <li>缺点：查找效率低，需要从头开始依次查找，直到找到目标数据为止；当需要在链表中间位置插入或删除数据时，插入或删除的效率都不高。</li></ul> <p>哈希表：</p> <ul><li>优点：哈希表的插入/查询/删除效率都非常高；</li> <li>缺点：空间利用率不高，底层使用的数组中很多单元没有被利用；并且哈希表中的元素是无序的，不能按照固定顺序遍历哈希表中的元素；而且不能快速找出哈希表中最大值或最小值这些特殊值。</li></ul> <p>树结构：</p> <ul><li>优点：树结构综合了上述三种结构的优点，同时也弥补了它们存在的缺点（虽然效率不一定都比它们高），比如树结构中数据都是有序的，查找效率高；空间利用率高；并且可以快速获取最大值和最小值等。</li></ul> <p>总的来说：每种数据结构都有自己特定的应用场景。</p> <p>树结构：</p> <ul><li><p>树（Tree）：由 n（n ≥ 0）个节点构成的有限集合。当 n = 0 时，称为空树。</p></li> <li><p>对于任意一棵非空树（n &gt; 0），它具备以下性质：</p> <ul><li>数中有一个称为根（Root）的特殊节点，用 <strong>r</strong> 表示；</li> <li>其余节点可分为 m（m &gt; 0）个互不相交的有限集合 T1，T2，...，Tm，其中每个集合本身又是一棵树，称为原来树的子树（SubTree）。</li></ul></li></ul> <h4 id="树的常用术语"><a href="#树的常用术语" class="header-anchor">#</a> 树的常用术语：</h4> <p><img src="/TechnicalNotes/assets/img/image.3t0ypfn5leo0.3e6cdb38.png" alt="image"></p> <ul><li>节点的度（Degree）：节点的子树个数，比如节点 B 的度为 2；</li> <li>树的度：树的所有节点中最大的度数，如上图树的度为 2；</li> <li>叶节点（Leaf）：度为 0 的节点（也称为叶子节点），如上图的 H，I 等；</li> <li>父节点（Parent）：度不为 0 的节点称为父节点，如上图节点 B 是节点 D 和 E 的父节点；</li> <li>子节点（Child）：若 B 是 D 的父节点，那么 D 就是 B 的子节点；</li> <li>兄弟节点（Sibling）：具有同一父节点的各节点彼此是兄弟节点，比如上图的 B 和 C，D 和 E 互为兄弟节点；</li> <li>路径和路径长度：路径指的是一个节点到另一节点的通道，路径所包含边的个数称为路径长度，比如 A-&gt;H 的路径长度为 3；</li> <li>节点的层次（Level）：规定根节点在 1 层，其他任一节点的层数是其父节点的层数加 1。如 B 和 C 节点的层次为 2；</li> <li>树的深度（Depth）：树种所有节点中的最大层次是这棵树的深度，如上图树的深度为 4；</li></ul> <h4 id="树结构的表示方式"><a href="#树结构的表示方式" class="header-anchor">#</a> 树结构的表示方式</h4> <h5 id="最普通的表示方法"><a href="#最普通的表示方法" class="header-anchor">#</a> 最普通的表示方法：</h5> <p><img src="/TechnicalNotes/assets/img/image.4v9sayu9zu60.8580800f.png" alt="image"></p> <p>如图，树结构的组成方式类似于链表，都是由一个个节点连接构成。不过，根据每个父节点子节点数量的不同，每一个父节点需要的引用数量也不同。比如节点 A 需要 3 个引用，分别指向子节点 B，C，D；B 节点需要 2 个引用，分别指向子节点 E 和 F；K 节点由于没有子节点，所以不需要引用。</p> <p>这种方法缺点在于我们无法确定某一结点的引用数。</p> <h5 id="儿子-兄弟表示法"><a href="#儿子-兄弟表示法" class="header-anchor">#</a> 儿子-兄弟表示法：</h5> <p><img src="/TechnicalNotes/assets/img/image.3o34yy6h0420.f2959c56.png" alt="image"></p> <p>这种表示方法可以完整地记录每个节点的数据，比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//节点A</span>
Node<span class="token punctuation">{</span>
  <span class="token comment">//存储数据</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data
  <span class="token comment">//统一只记录左边的子节点</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>leftChild <span class="token operator">=</span> <span class="token constant">B</span>
  <span class="token comment">//统一只记录右边的第一个兄弟节点</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>rightSibling <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>

<span class="token comment">//节点B</span>
Node<span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data
  <span class="token keyword">this</span><span class="token punctuation">.</span>leftChild <span class="token operator">=</span> <span class="token constant">E</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>rightSibling <span class="token operator">=</span> <span class="token constant">C</span>
<span class="token punctuation">}</span>

<span class="token comment">//节点F</span>
Node<span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data
  <span class="token keyword">this</span><span class="token punctuation">.</span>leftChild <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>rightSibling <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这种表示法的优点在于每一个节点中引用的数量都是确定的。</p> <h5 id="儿子-兄弟表示法旋转"><a href="#儿子-兄弟表示法旋转" class="header-anchor">#</a> 儿子-兄弟表示法旋转</h5> <p>以下为儿子-兄弟表示法组成的树结构：</p> <p><img src="/TechnicalNotes/assets/img/image.6tucreh71ok0.6dad478d.png" alt="image"></p> <p>将其顺时针旋转 45° 之后：</p> <p><img src="/TechnicalNotes/assets/img/image.4blmsiyhevg0.2b77143e.png" alt="image"></p> <p>这样就成为了一棵二叉树，由此我们可以得出结论：任何树都可以通过二叉树进行模拟。但是这样父节点不是变了吗？其实，父节点的设置只是为了方便指向子节点，在代码实现中谁是父节点并没有关系，只要能正确找到对应节点即可。</p> <h2 id="二叉树"><a href="#二叉树" class="header-anchor">#</a> 二叉树</h2> <h3 id="二叉树的概念"><a href="#二叉树的概念" class="header-anchor">#</a> 二叉树的概念</h3> <p>如果树中的每一个节点最多只能由两个子节点，这样的树就称为二叉树；</p> <h3 id="二叉树的组成"><a href="#二叉树的组成" class="header-anchor">#</a> 二叉树的组成</h3> <ul><li>二叉树可以为空，也就是没有节点；</li> <li>若二叉树不为空，则它由根节点和称为其左子树 TL 和右子树 TR 的两个不相交的二叉树组成；</li></ul> <h3 id="二叉树的五种形态"><a href="#二叉树的五种形态" class="header-anchor">#</a> 二叉树的五种形态</h3> <p><img src="/TechnicalNotes/assets/img/image.15ycsg4fqoio.6a73ed08.png" alt="image"></p> <p>上图分别表示：空的二叉树、只有一个节点的二叉树、只有左子树 TL 的二叉树、只有右子树 TR 的二叉树和有左右两个子树的二叉树。</p> <h3 id="二叉树的特性"><a href="#二叉树的特性" class="header-anchor">#</a> 二叉树的特性</h3> <ul><li>一个二叉树的第 i 层的最大节点树为：2^(i-1)^，i &gt;= 1；</li> <li>深度为 k 的二叉树的最大节点总数为：2^k^ - 1 ，k &gt;= 1；</li> <li>对任何非空二叉树，若 n~0~ 表示叶子节点的个数，n~2~表示度为 2 的非叶子节点个数，那么两者满足关系：n~0~ = n~2~ + 1；如下图所示：H，E，I，J，G 为叶子节点，总数为 5；A，B，C，F 为度为 2 的非叶子节点，总数为 4；满足 n~0~ = n~2~ + 1 的规律。</li></ul> <p><img src="/TechnicalNotes/assets/img/image.syjwffjltmo.01a612e7.png" alt="image"></p> <h3 id="特殊的二叉树"><a href="#特殊的二叉树" class="header-anchor">#</a> 特殊的二叉树</h3> <h4 id="完美二叉树"><a href="#完美二叉树" class="header-anchor">#</a> 完美二叉树</h4> <p>完美二叉树（Perfect Binary Tree）也成为满二叉树（Full Binary Tree），在二叉树中，除了最下一层的叶子节点外，每层节点都有 2 个子节点，这就构成了完美二叉树。</p> <p><img src="/TechnicalNotes/assets/img/image.223b2axrocf4.a6974ff9.png" alt="image"></p> <h4 id="完全二叉树"><a href="#完全二叉树" class="header-anchor">#</a> 完全二叉树</h4> <p>完全二叉树（Complete Binary Tree）:</p> <ul><li>除了二叉树最后一层外，其他各层的节点数都达到了最大值；</li> <li>并且，最后一层的叶子节点从左向右是连续存在，只缺失右侧若干叶子节点；</li> <li>完美二叉树是特殊的完全二叉树；</li></ul> <p><img src="/TechnicalNotes/assets/img/image.5y4rglrp8qk0.73413525.png" alt="image"></p> <p>在上图中，由于 H 缺失了右子节点，所以它不是完全二叉树。</p> <h3 id="二叉树的数据存储"><a href="#二叉树的数据存储" class="header-anchor">#</a> 二叉树的数据存储</h3> <p>常见的二叉树存储方式为数组和链表：</p> <h4 id="使用数组"><a href="#使用数组" class="header-anchor">#</a> 使用数组</h4> <ul><li>完全二叉树：按从上到下，从左到右的方式存储数据。</li></ul> <p><img src="/TechnicalNotes/assets/img/image.29w4k62b51og.bdfa20f1.png" alt="image"></p> <table><thead><tr><th style="text-align:center;">节点</th> <th style="text-align:center;">A</th> <th style="text-align:center;">B</th> <th style="text-align:center;">C</th> <th style="text-align:center;">D</th> <th style="text-align:center;">E</th> <th style="text-align:center;">F</th> <th style="text-align:center;">G</th> <th style="text-align:center;">H</th> <th style="text-align:center;">I</th></tr></thead> <tbody><tr><td style="text-align:center;">序号</td> <td style="text-align:center;">1</td> <td style="text-align:center;">2</td> <td style="text-align:center;">3</td> <td style="text-align:center;">4</td> <td style="text-align:center;">5</td> <td style="text-align:center;">6</td> <td style="text-align:center;">7</td> <td style="text-align:center;">8</td> <td style="text-align:center;">9</td></tr></tbody></table> <p>使用数组存储时，取数据的时候也十分方便：左子节点的序号等于父节点序号 _ 2，右子节点的序号等于父节点序号 _ 2 + 1 。</p> <ul><li>非完全二叉树：非完全二叉树需要转换成完全二叉树才能按照上面的方案存储，这样会浪费很大的存储空间。</li></ul> <p><img src="/TechnicalNotes/assets/img/image.4jgiq6r2xee0.7a2c60e4.png" alt="image"></p> <table><thead><tr><th style="text-align:center;">节点</th> <th style="text-align:center;">A</th> <th style="text-align:center;">B</th> <th style="text-align:center;">C</th> <th style="text-align:center;">^</th> <th style="text-align:center;">^</th> <th style="text-align:center;">F</th> <th style="text-align:center;">^</th> <th style="text-align:center;">^</th> <th style="text-align:center;">^</th> <th style="text-align:center;">^</th> <th style="text-align:center;">^</th> <th style="text-align:center;">^</th> <th style="text-align:center;">M</th></tr></thead> <tbody><tr><td style="text-align:center;">序号</td> <td style="text-align:center;">1</td> <td style="text-align:center;">2</td> <td style="text-align:center;">3</td> <td style="text-align:center;">4</td> <td style="text-align:center;">5</td> <td style="text-align:center;">6</td> <td style="text-align:center;">7</td> <td style="text-align:center;">8</td> <td style="text-align:center;">9</td> <td style="text-align:center;">10</td> <td style="text-align:center;">11</td> <td style="text-align:center;">12</td> <td style="text-align:center;">13</td></tr></tbody></table> <h4 id="使用链表"><a href="#使用链表" class="header-anchor">#</a> 使用链表</h4> <p>二叉树最常见的存储方式为链表：每一个节点封装成一个 Node，Node 中包含存储的数据、左节点的引用和右节点的引用。</p> <p><img src="/TechnicalNotes/assets/img/image.2mlscfad5420.a8836db9.png" alt="image"></p> <h2 id="二叉搜索树"><a href="#二叉搜索树" class="header-anchor">#</a> 二叉搜索树</h2> <p>二叉搜索树（BST，Binary Search Tree），也称为二叉排序树和二叉查找树。</p> <p>二叉搜索树是一棵二叉树，可以为空。</p> <p>如果不为空，则满足以下性质：</p> <ul><li>条件 1：非空左子树的所有键值小于其根节点的键值。比如三中节点 6 的所有非空左子树的键值都小于 6；</li> <li>条件 2：非空右子树的所有键值大于其根节点的键值；比如三中节点 6 的所有非空右子树的键值都大于 6；</li> <li>条件 3：左、右子树本身也都是二叉搜索树；</li></ul> <p><img src="/TechnicalNotes/assets/img/image.1lhxcdph4vpc.812c957f.png" alt="image"></p> <p>如上图所示，树二和树三符合 3 个条件属于二叉树，树一不满足条件 3 所以不是二叉树。</p> <p>总结：二叉搜索树的特点主要是较小的值总是保存在左节点上，相对较大的值总是保存在右节点上。这种特点使得二叉搜索树的查询效率非常高，这也就是二叉搜索树中“搜索”的来源。</p> <h3 id="二叉搜索树应用举例"><a href="#二叉搜索树应用举例" class="header-anchor">#</a> 二叉搜索树应用举例</h3> <p>下面是一个二叉搜索树：</p> <p><img src="/TechnicalNotes/assets/img/image.3l21fsg6qbc0.61f9307f.png" alt="image"></p> <p>若想在其中查找数据 10，只需要查找 4 次，查找效率非常高。</p> <ul><li>第 1 次：将 10 与根节点 9 进行比较，由于 10 &gt; 9，所以 10 下一步与根节点 9 的右子节点 13 比较；</li> <li>第 2 次：由于 10 &lt; 13，所以 10 下一步与父节点 13 的左子节点 11 比较；</li> <li>第 3 次：由于 10 &lt; 11，所以 10 下一步与父节点 11 的左子节点 10 比较；</li> <li>第 4 次：由于 10 = 10，最终查找到数据 10 。</li></ul> <p><img src="/TechnicalNotes/assets/img/image.5x9xyvmbxy80.dfcccb09.png" alt="image"></p> <p>同样是 15 个数据，在排序好的数组中查询数据 10，需要查询 10 次：</p> <p><img src="/TechnicalNotes/assets/img/image.2gqz4t2jekw0.06f1ca3d.png" alt="image"></p> <p>其实：如果是排序好的数组，可以通过二分查找：第一次找 9，第二次找 13，第三次找 15...。我们发现如果把每次二分的数据拿出来以树的形式表示的话就是二叉搜索树。这就是数组二分法查找效率之所以高的原因。</p> <h3 id="二叉搜索树的封装"><a href="#二叉搜索树的封装" class="header-anchor">#</a> 二叉搜索树的封装</h3> <p>二叉搜索树有四个最基本的属性：指向节点的根（root），节点中的键（key）、左指针（right）、右指针（right）。</p> <p><img src="/TechnicalNotes/assets/img/image.5vdbb5to1n40.cd14c1c1.png" alt="image"></p> <p>所以，二叉搜索树中除了定义 root 属性外，还应定义一个节点内部类，里面包含每个节点中的 left、right 和 key 三个属性。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 节点类</span>
<span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="二叉搜索树的常见操作"><a href="#二叉搜索树的常见操作" class="header-anchor">#</a> 二叉搜索树的常见操作：</h3> <ul><li><code>insert(key)</code> 向树中插入一个新的键。</li> <li><code>search(key)</code> 在树中查找一个键，如果节点存在，则返回 true；如果不存在，则返回 <code>false</code>。</li> <li><code>preOrderTraverse</code> 通过先序遍历方式遍历所有节点。</li> <li><code>inOrderTraverse</code> 通过中序遍历方式遍历所有节点。</li> <li><code>postOrderTraverse</code> 通过后序遍历方式遍历所有节点。</li> <li><code>min</code> 返回树中最小的值/键。</li> <li><code>max</code> 返回树中最大的值/键。</li> <li><code>remove(key)</code> 从树中移除某个键。</li></ul> <h4 id="插入数据"><a href="#插入数据" class="header-anchor">#</a> 插入数据</h4> <p>实现思路：</p> <ul><li>首先根据传入的 key 创建节点对象。</li> <li>然后判断根节点是否存在，不存在时通过：this.root = newNode，直接把新节点作为二叉搜索树的根节点。</li> <li>若存在根节点则重新定义一个内部方法 <code>insertNode()</code> 用于查找插入点。</li></ul> <p>insert(key) 代码实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// insert(key) 插入数据</span>
<span class="token function">insert</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p>insertNode() 的实现思路:</p> <p>根据比较传入的两个节点，一直查找新节点适合插入的位置，直到成功插入新节点为止。</p> <ul><li><p>当 newNode.key &lt; node.key 向左查找:</p> <ul><li><p>情况 1：当 node 无左子节点时，直接插入：</p></li> <li><p>情况 2：当 node 有左子节点时，递归调用 insertNode()，直到遇到无左子节点成功插入 newNode 后，不再符合该情况，也就不再调用 insertNode()，递归停止。</p></li></ul></li> <li><p>当 newNode.key &gt;= node.key 向右查找，与向左查找类似：</p> <ul><li><p>情况 1：当 node 无右子节点时，直接插入：</p></li> <li><p>情况 2：当 node 有右子节点时，依然递归调用 insertNode()，直到遇到传入 insertNode 方法 的 node 无右子节点成功插入 newNode 为止。</p></li></ul></li></ul> <p>insertNode(root, node) 代码实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 往左边查找插入</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      root<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 往右边查找插入</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      root<span class="token punctuation">.</span>right <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

  <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><h4 id="遍历数据"><a href="#遍历数据" class="header-anchor">#</a> 遍历数据</h4> <p>这里所说的树的遍历不仅仅针对二叉搜索树，而是适用于所有的二叉树。由于树结构不是线性结构，所以遍历方式有多种选择，常见的三种二叉树遍历方式为：</p> <ul><li>先序遍历；</li> <li>中序遍历；</li> <li>后序遍历；</li></ul> <p>还有层序遍历，使用较少。</p> <h5 id="先序遍历"><a href="#先序遍历" class="header-anchor">#</a> 先序遍历</h5> <p>先序遍历的过程为：</p> <p>首先，遍历根节点；
然后，遍历其左子树；
最后，遍历其右子树；</p> <p><img src="/TechnicalNotes/assets/img/image.69ooahvtbbo0.8ead9a20.png" alt="image"></p> <p>如上图所示，二叉树的节点遍历顺序为：A -&gt; B -&gt; D -&gt; H -&gt; I -&gt; E -&gt; C -&gt; F -&gt; G。</p> <p>代码实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 先序遍历（根左右 DLR）</span>
<span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">preorderTraversalNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">preorderTraversalNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">preorderTraversalNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">preorderTraversalNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="中序遍历"><a href="#中序遍历" class="header-anchor">#</a> 中序遍历</h5> <p>实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。</p> <p>首先，遍历其左子树；
然后，遍历根（父）节点；
最后，遍历其右子树；</p> <p>过程图解：</p> <p><img src="/TechnicalNotes/assets/img/image.762l4sxdr7o0.a2a3b8a3.png" alt="image"></p> <p>输出节点的顺序应为：3 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 11 -&gt; 12 -&gt; 13 -&gt; 14 -&gt; 15 -&gt; 18 -&gt; 20 -&gt; 25 。</p> <p>代码实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 中序遍历（左根右 LDR）</span>
<span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">inorderTraversalNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">inorderTraversalNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">inorderTraversalNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">inorderTraversalNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="后序遍历"><a href="#后序遍历" class="header-anchor">#</a> 后序遍历</h5> <p>实现思路：与先序遍历原理相同，只不过是遍历的顺序不一样了。</p> <p>首先，遍历其左子树；
然后，遍历其右子树；
最后，遍历根（父）节点；</p> <p>过程图解：</p> <p><img src="/TechnicalNotes/assets/img/image.5lqmen4jds80.a13f47c9.png" alt="image"></p> <p>输出节点的顺序应为：3 -&gt; 6 -&gt; 5 -&gt; 8 -&gt; 10 -&gt; 9 -&gt; 7 -&gt; 12 -&gt; 14 -&gt; 13 -&gt; 18 -&gt; 25 -&gt; 20 -&gt; 15 -&gt; 11 。</p> <p>代码实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 后序遍历（左右根 LRD）</span>
<span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">postorderTraversalNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">postorderTraversalNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">postorderTraversalNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">postorderTraversalNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h5> <p>以遍历根（父）节点的顺序来区分三种遍历方式。比如：先序遍历先遍历根节点、中序遍历第二遍历根节点、后续遍历最后遍历根节点。</p> <h4 id="查找数据"><a href="#查找数据" class="header-anchor">#</a> 查找数据</h4> <h5 id="查找最大值或最小值"><a href="#查找最大值或最小值" class="header-anchor">#</a> 查找最大值或最小值</h5> <p>在二叉搜索树中查找最值非常简单，最小值在二叉搜索树的最左边，最大值在二叉搜索树的最右边。只需要一直向左/右查找就能得到最值，如下图所示：</p> <p><img src="/TechnicalNotes/assets/img/image.3h3yfhyqgi00.5b7afddb.png" alt="image"></p> <p>代码实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// min() 获取二叉搜索树最小值</span>
<span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    node <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> node<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// max() 获取二叉搜索树最大值</span>
<span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    node <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> node<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="查找特定值"><a href="#查找特定值" class="header-anchor">#</a> 查找特定值</h5> <p>查找二叉搜索树当中的特定值效率也非常高。只需要从根节点开始将需要查找节点的 key 值与之比较，若 node.key &lt; root 则向左查找，若 node.key &gt; root 就向右查找，直到找到或查找到 null 为止。这里可以使用递归实现，也可以采用循环来实现。</p> <p>代码实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// search(key) 查找二叉搜索树中是否有相同的key，存在返回 true，否则返回 false</span>
<span class="token function">search</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">searchNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 通过递归实现</span>
<span class="token function">searchNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">searchNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&gt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">searchNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 通过 while 循环实现</span>
<span class="token function">search2</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&gt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre></div><h4 id="删除数据"><a href="#删除数据" class="header-anchor">#</a> 删除数据</h4> <p>实现思路：</p> <p>第一步：先找到需要删除的节点，若没找到，则不需要删除；</p> <p>首先定义变量 current 用于保存需要删除的节点、变量 parent 用于保存它的父节点、变量 isLeftChild 保存 current 是否为 parent 的左节点，这样方便之后删除节点时改变相关节点的指向。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>
<span class="token keyword">let</span> parentNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> isLeftChild <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token comment">// 循环查找到要删除的节点 currentNode，以及它的 parentNode、isLeftChild</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>key <span class="token operator">!==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  parentNode <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>

  <span class="token comment">// 小于，往左查找</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> currentNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    isLeftChild <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 否则往右查找</span>
    isLeftChild <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 找到最后都没找到相等的节点，返回 false</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>第二步：删除找到的指定节点，后分 3 种情况：</p> <ul><li>删除的是叶子节点；</li> <li>删除的是只有一个子节点的节点；</li> <li>删除的是有两个子节点的节点；</li></ul> <h5 id="删除的是叶子节点"><a href="#删除的是叶子节点" class="header-anchor">#</a> 删除的是叶子节点</h5> <p>删除的是叶子节点分两种情况：</p> <ul><li><p>叶子节点也是根节点</p> <p>当该叶子节点为根节点时，如下图所示，此时 current == this.root，直接通过：this.root = null，删除根节点。</p> <p><img src="data:image/png;base64,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" alt="image"></p></li> <li><p>叶子节点不为根节点</p> <p>当该叶子节点不为根节点时也有两种情况，如下图所示</p> <p><img src="data:image/png;base64,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" alt="image"></p> <p>若 current = 8，可以通过：parent.left = null，删除节点 8；</p> <p>若 current = 10，可以通过：parent.right = null，删除节点 10；</p> <p>代码实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 1、删除的是叶子节点的情况</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>left <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> currentNode<span class="token punctuation">.</span>right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isLeftChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    parentNode<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    parentNode<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 2、删除的是只有一个子节点的节点</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h5 id="删除的是只有一个子节点的节点"><a href="#删除的是只有一个子节点的节点" class="header-anchor">#</a> 删除的是只有一个子节点的节点</h5> <p>有六种情况：</p> <p>当 current 存在左子节点时（current.right == null）：</p> <ul><li><p>情况 1：current 为根节点（current == this.root），如节点 11，此时通过：this.root = current.left，删除根节点 11；</p></li> <li><p>情况 2：current 为父节点 parent 的左子节点（isLeftChild == true），如节点 5，此时通过：parent.left = current.left，删除节点 5；</p></li> <li><p>情况 3：current 为父节点 parent 的右子节点（isLeftChild == false），如节点 9，此时通过：parent.right = current.left，删除节点 9；</p></li></ul> <p><img src="/TechnicalNotes/assets/img/image.27lwqd0qfnpc.4f562883.png" alt="image"></p> <p>当 current 存在右子节点时（current.left = null）：</p> <ul><li><p>情况 4：current 为根节点（current == this.root），如节点 11，此时通过：this.root = current.right，删除根节点 11。</p></li> <li><p>情况 5：current 为父节点 parent 的左子节点（isLeftChild == true），如节点 5，此时通过：parent.left = current.right，删除节点 5；</p></li> <li><p>情况 6：current 为父节点 parent 的右子节点（isLeftChild == false），如节点 9，此时通过：parent.right = current.right，删除节点 9；</p></li></ul> <p><img src="/TechnicalNotes/assets/img/image.3edzg72fx7y0.966a77bf.png" alt="image"></p> <p>代码实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 2、删除的是只有一个子节点的节点</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// currentNode 只存在左节点</span>
  <span class="token comment">//-- 2.1、currentNode 只存在&lt;左节点&gt;的情况</span>
  <span class="token comment">//---- 2.1.1、currentNode 等于 root</span>
  <span class="token comment">//---- 2.1.2、parentNode.left 等于 currentNode</span>
  <span class="token comment">//---- 2.1.3、parentNode.right 等于 currentNode</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isLeftChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    parentNode<span class="token punctuation">.</span>left <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    parentNode<span class="token punctuation">.</span>right <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>left <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// currentNode 只存在右节点</span>
  <span class="token comment">//-- 2.2、currentNode 只存在&lt;右节点&gt;的情况</span>
  <span class="token comment">//---- 2.1.1 currentNode 等于 root</span>
  <span class="token comment">//---- 2.1.1 parentNode.left 等于 currentNode</span>
  <span class="token comment">//---- 2.1.1 parentNode.right 等于 currentNode</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isLeftChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    parentNode<span class="token punctuation">.</span>left <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    parentNode<span class="token punctuation">.</span>right <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><h5 id="删除的是有两个子节点的节点"><a href="#删除的是有两个子节点的节点" class="header-anchor">#</a> 删除的是有两个子节点的节点</h5> <p>这种情况十分复杂，首先依据以下二叉搜索树，讨论这样的问题：</p> <p><img src="/TechnicalNotes/assets/img/image.4g0geeyv6ya0.fe50e27a.png" alt="image"></p> <p><strong>删除节点 9</strong></p> <p>在保证删除节点 9 后原二叉树仍为二叉搜索树的前提下，有两种方式：</p> <ul><li>方式 1：从节点 9 的左子树中选择一合适的节点替代节点 9，可知节点 8 符合要求；</li> <li>方式 2：从节点 9 的右子树中选择一合适的节点替代节点 9，可知节点 10 符合要求；</li></ul> <p><img src="/TechnicalNotes/assets/img/image.73rduwimfvo0.fe50e27a.png" alt="image"></p> <p><strong>删除节点 7</strong></p> <p>在保证删除节点 7 后原二叉树仍为二叉搜索树的前提下，也有两种方式：</p> <ul><li>方式 1：从节点 7 的左子树中选择一合适的节点替代节点 7，可知节点 5 符合要求；</li> <li>方式 2：从节点 7 的右子树中选择一合适的节点替代节点 7，可知节点 8 符合要求；</li></ul> <p><img src="/TechnicalNotes/assets/img/image.2h9hjd5bhwo0.e646766d.png" alt="image"></p> <p><strong>删除节点 15</strong></p> <p>在保证删除节点 15 后原树二叉树仍为二叉搜索树的前提下，同样有两种方式：</p> <ul><li>方式 1：从节点 15 的左子树中选择一合适的节点替代节点 15，可知节点 14 符合要求；</li> <li>方式 2：从节点 15 的右子树中选择一合适的节点替代节点 15，可知节点 18 符合要求；</li></ul> <p><img src="/TechnicalNotes/assets/img/image.4f5tzwdvueq0.c3007ff5.png" alt="image"></p> <p>相信你已经发现其中的规律了！</p> <p>规律总结：如果要删除的节点有两个子节点，甚至子节点还有子节点，这种情况下需要从要删除节点下面的子节点中找到一个合适的节点，来替换当前的节点。</p> <p>若用 current 表示需要删除的节点，则合适的节点指的是：</p> <ul><li>current 左子树中比 current 小一点点的节点，即 current 左子树中的最大值；</li> <li>current 右子树中比 current 大一点点的节点，即 current 右子树中的最小值；</li></ul> <h6 id="前驱-后继"><a href="#前驱-后继" class="header-anchor">#</a> 前驱&amp;后继</h6> <p>在二叉搜索树中，这两个特殊的节点有特殊的名字：</p> <ul><li>比 current 小一点点的节点，称为 current 节点的前驱。比如下图中的节点 5 就是节点 7 的前驱；</li> <li>比 current 大一点点的节点，称为 current 节点的后继。比如下图中的节点 8 就是节点 7 的后继；</li></ul> <p><img src="data:image/png;base64,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" alt="image"></p> <p>查找需要被删除的节点 current 的后继时，需要在 current 的右子树中查找最小值，即在 current 的右子树中一直向左遍历查找；</p> <p>查找前驱时，则需要在 current 的左子树中查找最大值，即在 current 的左子树中一直向右遍历查找。</p> <p>下面只讨论查找 current 后继的情况，查找前驱的原理相同，这里暂不讨论。</p> <p>代码实现：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">// 3、删除的是有两个子节点的节点</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>

    <span class="token comment">// 1、找到后续节点</span>
    <span class="token keyword">let</span> successor <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSuccessor</span><span class="token punctuation">(</span>currentNode<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、判断是否为根节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> successor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isLeftChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>left <span class="token operator">=</span> successor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>right <span class="token operator">=</span> successor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3、将后续的左节点改为被删除的左节点</span>
    successor<span class="token punctuation">.</span>left <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取后续节点，即从要删除的节点的右边开始查找最小的值</span>
<span class="token function">getSuccessor</span><span class="token punctuation">(</span><span class="token parameter">delNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token comment">// 定义变量，保存要找到的后续</span>
  <span class="token keyword">let</span> successor <span class="token operator">=</span> delNode<span class="token punctuation">;</span>
  <span class="token keyword">let</span> current <span class="token operator">=</span> delNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token keyword">let</span> successorParent <span class="token operator">=</span> delNode<span class="token punctuation">;</span>

  <span class="token comment">// 循环查找 current 的右子树节点</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    successorParent <span class="token operator">=</span> successor<span class="token punctuation">;</span>
    successor <span class="token operator">=</span> current<span class="token punctuation">;</span>
    current <span class="token operator">=</span> current<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 判断寻找到的后续节点是否直接就是要删除节点的 right</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>successor <span class="token operator">!==</span> delNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    successorParent<span class="token punctuation">.</span>left <span class="token operator">=</span> successor<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    successor<span class="token punctuation">.</span>right <span class="token operator">=</span> delNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> successor<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="完整实现"><a href="#完整实现" class="header-anchor">#</a> 完整实现</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 删除节点</span>
<span class="token function">remove</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token keyword">let</span> currentNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">;</span>
  <span class="token keyword">let</span> parentNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> isLeftChild <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

  <span class="token comment">// 循环查找到要删除的节点 currentNode，以及它的 parentNode、isLeftChild</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>key <span class="token operator">!==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    parentNode <span class="token operator">=</span> currentNode<span class="token punctuation">;</span>

    <span class="token comment">// 小于，往左查找</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">&lt;</span> currentNode<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      isLeftChild <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment">// 否则往右查找</span>
      isLeftChild <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      currentNode <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 找到最后都没找到相等的节点，返回 false</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

  <span class="token punctuation">}</span>


  <span class="token comment">// 1、删除的是叶子节点的情况</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>left <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> currentNode<span class="token punctuation">.</span>right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isLeftChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token comment">// 2、删除的是只有一个子节点的节点</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// currentNode 只存在左节点</span>
    <span class="token comment">//-- 2.1、currentNode 只存在&lt;左节点&gt;的情况</span>
    <span class="token comment">//---- 2.1.1、currentNode 等于 root</span>
    <span class="token comment">//---- 2.1.2、parentNode.left 等于 currentNode</span>
    <span class="token comment">//---- 2.1.3、parentNode.right 等于 currentNode</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isLeftChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>left <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>right <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode<span class="token punctuation">.</span>left <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// currentNode 只存在右节点</span>
    <span class="token comment">//-- 2.2、currentNode 只存在&lt;右节点&gt;的情况</span>
    <span class="token comment">//---- 2.1.1 currentNode 等于 root</span>
    <span class="token comment">//---- 2.1.1 parentNode.left 等于 currentNode</span>
    <span class="token comment">//---- 2.1.1 parentNode.right 等于 currentNode</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isLeftChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>left <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>right <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token comment">// 3、删除的是有两个子节点的节点</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>

    <span class="token comment">// 1、找到后续节点</span>
    <span class="token keyword">let</span> successor <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSuccessor</span><span class="token punctuation">(</span>currentNode<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 2、判断是否为根节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentNode <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> successor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isLeftChild<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>left <span class="token operator">=</span> successor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      parentNode<span class="token punctuation">.</span>right <span class="token operator">=</span> successor<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3、将后续的左节点改为被删除的左节点</span>
    successor<span class="token punctuation">.</span>left <span class="token operator">=</span> currentNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取后续节点，即从要删除的节点的右边开始查找最小的值</span>
<span class="token function">getSuccessor</span><span class="token punctuation">(</span><span class="token parameter">delNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token comment">// 定义变量，保存要找到的后续</span>
  <span class="token keyword">let</span> successor <span class="token operator">=</span> delNode<span class="token punctuation">;</span>
  <span class="token keyword">let</span> current <span class="token operator">=</span> delNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token keyword">let</span> successorParent <span class="token operator">=</span> delNode<span class="token punctuation">;</span>

  <span class="token comment">// 循环查找 current 的右子树节点</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    successorParent <span class="token operator">=</span> successor<span class="token punctuation">;</span>
    successor <span class="token operator">=</span> current<span class="token punctuation">;</span>
    current <span class="token operator">=</span> current<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 判断寻找到的后续节点是否直接就是要删除节点的 right</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>successor <span class="token operator">!==</span> delNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    successorParent<span class="token punctuation">.</span>left <span class="token operator">=</span> successor<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    successor<span class="token punctuation">.</span>right <span class="token operator">=</span> delNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> successor<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="平衡树"><a href="#平衡树" class="header-anchor">#</a> 平衡树</h2> <p>二叉搜索树的缺陷：当插入的数据是有序的数据，就会造成二叉搜索树的深度过大。比如原二叉搜索树由 11 7 15 组成，如下图所示：</p> <p><img src="data:image/png;base64,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" alt="image"></p> <p>当插入一组有序数据：6 5 4 3 2 就会变成深度过大的搜索二叉树，会严重影响二叉搜索树的性能。</p> <p><img src="/TechnicalNotes/assets/img/image.154bnlgtd5z4.14a854f0.png" alt="image"></p> <p>非平衡树</p> <ul><li>比较好的二叉搜索树，它的数据应该是左右均匀分布的。</li> <li>但是插入连续数据后，二叉搜索树中的数据分布就变得不均匀了，我们称这种树为非平衡树。</li> <li>对于一棵平衡二叉树来说，插入/查找等操作的效率是 O(log n)。</li> <li>而对于一棵非平衡二叉树来说，相当于编写了一个链表，查找效率变成了 O(n)。</li></ul> <p>树的平衡性</p> <p>为了能以较快的时间 O(log n)来操作一棵树，我们需要保证树总是平衡的：</p> <ul><li>起码大部分是平衡的，此时的时间复杂度也是接近 O(log n) 的；</li> <li>这就要求树中每个节点左边的子孙节点的个数，应该尽可能地等于右边的子孙节点的个数；</li></ul> <p>常见的平衡树</p> <ul><li>AVL 树：是最早的一种平衡树，它通过在每个节点多存储一个额外的数据来保持树的平衡。由于 AVL 树是平衡树，所以它的时间复杂度也是 O(log n)。但是它的整体效率不如红黑树，开发中比较少用。</li> <li>红黑树：同样通过一些特性来保持树的平衡，时间复杂度也是 O(log n)。进行插入/删除等操作时，性能优于 AVL 树，所以平衡树的应用基本都是红黑树。</li></ul> <h2 id="图"><a href="#图" class="header-anchor">#</a> 图</h2> <p>在计算机程序设计中，图也是一种非常常见的数据结构，图论其实是一个非常大的话题，在数学上起源于哥尼斯堡七桥问题。</p> <h3 id="什么是图"><a href="#什么是图" class="header-anchor">#</a> 什么是图？</h3> <ul><li><p>图是一种与树有些相似的数据结构。</p> <ul><li>实际上，在数学的概念上，树是图的一种。</li> <li>我们知道树可以用来模拟很多现实的数据结构，比如：家谱/公司组织架构等等。</li></ul></li> <li><p>那么图长什么样子呢？或者什么样的数据使用图来模拟更合适呢？</p> <ul><li><p>人与人之间的关系网
<img src="/TechnicalNotes/assets/img/image.4cdhxz0ereu0.830e9092.png" alt="image"></p></li> <li><p>互联网中的网络关系
<img src="/TechnicalNotes/assets/img/image.4ljxyy69a1s0.c15f3e94.png" alt="image"></p></li> <li><p>广州地铁图
<img src="/TechnicalNotes/assets/img/image.46k2cvwmthw0.9b5e497a.png" alt="image"></p></li></ul></li> <li><p>那么，什么是图呢?</p> <ul><li>我们会发现，上面的结点（其实图中叫顶点 Vertex）之间的关系，是不能使用树来表示（几叉树都不可以）。</li> <li>这个时候，我们就可以使用<strong>图</strong>来模拟它们。</li></ul></li> <li><p>图通常有什么特点呢？</p> <ul><li>一组顶点：通常用 V (Vertex) 表示顶点的集合</li> <li>一组边：通常用 E (Edge) 表示边的集合</li> <li>边是顶点和顶点之间的连线</li> <li>边可以是有向的，也可以是无向的。（比如 A --- B，通常表示无向。 A --&gt; B，通常表示有向）</li></ul></li></ul> <h3 id="图的术语"><a href="#图的术语" class="header-anchor">#</a> 图的术语</h3> <h4 id="术语"><a href="#术语" class="header-anchor">#</a> 术语</h4> <ul><li><p>我们在学习树的时候，树有很多的其他术语，了解这些术语有助于我们更深层次的理解图。</p></li> <li><p>但是图的术语其实非常多，如果你找一本专门讲图的各个方面的书籍，会发现只是术语就可以占据一个章节。</p></li> <li><p>这里，这里介绍几个比较常见的术语，某些术语后面用到的时候，再了解，没有用到的，不做赘述。</p></li> <li><p>下面这是个抽象出来的图
<img src="/TechnicalNotes/assets/img/image.rr153grdbc0.48b74e62.png" alt="image"></p></li> <li><p>顶点</p> <ul><li>顶点刚才我们已经介绍过了，表示图中的一个结点。</li> <li>比如地铁站中某个站/多个村庄中的某个村庄/互联网中的某台主机/人际关系中的人。</li></ul></li> <li><p>边</p> <ul><li>边表示顶点和顶点之间的连线。</li> <li>比如地铁站中两个站点之间的直接连线, 就是一个边。</li> <li>注意：这里的边不要叫做路径，路径有其他的概念，后面会区分。</li></ul></li> <li><p>相邻顶点</p> <ul><li>由一条边连接在一起的顶点称为相邻顶点。</li> <li>比如 <code>0 - 1</code> 是相邻的，<code>0 - 3</code> 是相邻的。<code>0 - 2</code> 是不相邻的。</li></ul></li> <li><p>度</p> <ul><li>一个顶点的度是相邻顶点的数量</li> <li>比如 0 顶点和其他两个顶点相连，0 顶点的度是 2</li> <li>比如 1 顶点和其他四个顶点相连，1 顶点的度是 4</li></ul></li> <li><p>路径</p> <ul><li>路径是顶点 <code>v1</code>，<code>v2</code>...，<code>vn</code> 的一个连续序列, 比如上图中 <code>0 1 5 9</code> 就是一条路径。</li> <li>简单路径: 简单路径要求不包含重复的顶点. 比如 <code>0 1 5 9</code> 是一条简单路径。</li> <li>回路：第一个顶点和最后一个顶点相同的路径称为回路。比如 <code>0 1 5 6 3 0</code>。</li></ul></li> <li><p>无向图</p> <ul><li>上面的图就是一张无向图，因为所有的边都没有方向。</li> <li>比如 <code>0 - 1</code> 之间有边，那么说明这条边可以保证 <code>0 -&gt; 1</code>，也可以保证 <code>1 -&gt; 0</code>。</li></ul></li> <li><p>有向图</p> <ul><li>有向图表示的图中的边是有方向的。</li> <li>比如 <code>0 -&gt; 1</code>，不能保证一定可以 <code>1 -&gt; 0</code>，要根据方向来定。</li></ul></li></ul> <h4 id="无权图和带权图"><a href="#无权图和带权图" class="header-anchor">#</a> 无权图和带权图</h4> <ul><li><p>无权图</p> <ul><li>我们上面的图就是一张无权图（边没有携带权重）</li> <li>我们上面的图中的边是没有任何意义的，不能收 <code>0 - 1</code> 的边，比 <code>4 - 9</code> 的边更远或者用的时间更长。</li></ul></li> <li><p>带权图</p> <ul><li>带权图表示边有一定的权重</li> <li>这里的权重可以是任意你希望表示的数据：比如距离或者花费的时间或者票价。</li> <li>我们来看一张有向和带权的图
<img src="/TechnicalNotes/assets/img/image.3q0nj5eq5p80.aaa17da0.png" alt="image"></li></ul></li></ul> <h3 id="现实建模"><a href="#现实建模" class="header-anchor">#</a> 现实建模</h3> <ul><li><p>对交通流量建模</p> <ul><li>顶点可以表示街道的十字路口，边可以表示街道.。</li> <li>加权的边可以表示限速或者车道的数量或者街道的距离。</li> <li>建模人员可以用这个系统来判定最佳路线以及最可能堵车的街道。</li></ul></li> <li><p>对飞机航线建模</p> <ul><li>航空公司可以用图来为其飞行系统建模。</li> <li>将每个机场看成顶点，将经过两个顶点的每条航线看作一条边。</li> <li>加权的边可以表示从一个机场到另一个机场的航班成本，或两个机场间的距离。</li> <li>建模人员可以利用这个系统有效的判断从一个城市到另一个城市的最小航行成本。</li></ul></li></ul> <h2 id="图的表示"><a href="#图的表示" class="header-anchor">#</a> 图的表示</h2> <p>我们知道一个图包含很多顶点，另外包含顶点和顶点之间的连线（边），这两个都是非常重要的图信息，因此都需要在程序中体现出来。</p> <h3 id="顶点表示"><a href="#顶点表示" class="header-anchor">#</a> 顶点表示</h3> <ul><li><p>顶点的表示相对简单</p> <ul><li>上面的顶点，我们抽象成了 1 2 3 4，也可以抽象成 A B C D。在后面的案例中，我们使用 A B C D。</li> <li>那么这些 A B C D 我们可以使用一个数组来存储起来(存储所有的顶点)。</li> <li>当然，A B C D 有可能还表示其他含义的数据(比如村庄的名字)，这个时候，可以另外创建一个数组，用于存储对应的其他数据。</li></ul></li> <li><p>边的表示略微复杂</p> <ul><li>因为边是两个顶点之间的关系，所以表示起来会稍微麻烦一些。</li> <li>下面是变常见的表示方式。</li></ul></li></ul> <h3 id="邻接矩阵"><a href="#邻接矩阵" class="header-anchor">#</a> 邻接矩阵</h3> <ul><li><p>概述</p> <ul><li>邻接矩阵让每个节点和一个整数向关联, 该整数作为数组的下标值.</li> <li>我们用一个二维数组来表示顶点之间的连接.</li> <li>演示
<img src="/TechnicalNotes/assets/img/image.66y7l5b21nw0.68764983.png" alt="image"></li></ul></li> <li><p>图片解析</p> <ul><li>在二维数组中，0 表示没有连线，1 表示有连线。</li> <li>通过二维数组，我们可以很快的找到一个顶点和哪些顶点有连线。（比如 A 顶点, 只需要 遍历第一行即可）</li> <li>另外，A - A，B - B（也就是顶点到自己的连线），通常使用 0 表示。</li></ul></li> <li><p>邻接矩阵的问题</p> <ul><li><p>如果是一个无向图，邻接矩阵展示出来的二维数组，其实是一个对称图。</p> <ul><li>也就是 A -&gt; D 是 1 的时候，对称的位置 D -&gt; 1 一定也是 1。</li> <li>那么这种情况下会造成空间的浪费，解决办法需自己去研究下。</li></ul></li> <li><p>邻接矩阵还有一个比较严重的问题就是如果图是一个稀疏图</p> <ul><li>那么矩阵中将存在大量的 0，这意味着我们浪费了计算机存储空间来表示根本不存在的边。</li> <li>而且即使只有一个边，我们也必须遍历一行来找出这个边，也浪费很多时间。</li></ul></li></ul></li></ul> <h3 id="邻接表"><a href="#邻接表" class="header-anchor">#</a> 邻接表</h3> <ul><li><p>概述</p> <ul><li>邻接表由图中每个顶点以及和顶点相邻的顶点列表组成。</li> <li>这个列表有很多中方式来存储：数组/链表/字典(哈希表)都可以。</li> <li>演示
<img src="/TechnicalNotes/assets/img/image.3mu1hv8a84u0.f01ccb1b.png" alt="image"></li></ul></li> <li><p>图片解析</p> <ul><li>其实图片比较容易理解</li> <li>比如我们要表示和 A 顶点有关联的顶点（边），A 和 B/C/D 有边，那么我们可以通过 A 找到 对应的数组/链表/字典，再取出其中的内容就可以啦。</li></ul></li> <li><p>邻接表的问题</p> <ul><li>邻接表计算“出度”是比较简单的（出度：指向别人的数量, 入度: 指向自己的数量）</li> <li>邻接表如果需要计算有向图的“入度”，那么是一件非常麻烦的事情。</li> <li>它必须构造一个“逆邻接表”，才能有效的计算“入度”。而临街矩阵会非常简单。</li></ul></li></ul> <h2 id="图的封装"><a href="#图的封装" class="header-anchor">#</a> 图的封装</h2> <h3 id="创建图类"><a href="#创建图类" class="header-anchor">#</a> 创建图类</h3> <ul><li>先来创建 Graph 类，定义了两个属性：
<ul><li><code>vertexes</code> 用于存储所有的顶点，使用一个数组来保存。</li> <li><code>adjList</code> adj 是 adjoin 的缩写，邻接的意思。adjList 用于存储所有的边，这里采用邻接表的形式。</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>vertexes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 存储顶点</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>adjList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dictionay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//存储边信息</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="添加方法"><a href="#添加方法" class="header-anchor">#</a> 添加方法</h3> <ul><li>添加顶点：可以向图中添加一些顶点。
<ul><li>将添加的顶点放入到数组中。</li> <li>另外，给该顶点创建一个数组<code>[]</code>，该数组用于存储顶点连接的所有的边.（回顾邻接表的实现方式）</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 添加顶点</span>
<span class="token function">addVertex</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 添加点</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>vertexes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
    <span class="token comment">// 添加点的关系  采用邻接矩阵法 结构用Map</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>adjList<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>添加边：可以指定顶点和顶点之间的边。
<ul><li>添加边需要传入两个顶点，因为边是两个顶点之间的边，边不可能单独存在。</li> <li>根据顶点 v 取出对应的数组，将 w 加入到它的数组中。</li> <li>根据顶点 w 取出对应的数组，将 v 加入到它的数组中。</li> <li>因为这里实现的是无向图，所以边是可以双向的。</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 添加边</span>
<span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token parameter">val1<span class="token punctuation">,</span> val2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 添加边需要传入两个顶点, 因为边是两个顶点之间的边, 边不可能单独存在.</span>
    <span class="token comment">// 这里实现的是无向图, 所以这里不考虑方向问题</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>adjList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>val1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val2<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>adjList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>val2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val1<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>toString 方法：为了能够正确的显示图的结果，就是拿出二维数组的每一项。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 输出图结构</span>
<span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token string">''</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vertexes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        res <span class="token operator">+=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vertexes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">&quot;-&gt;&quot;</span>
        <span class="token keyword">let</span> adj <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>adjList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vertexes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> adj<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            res <span class="token operator">+=</span> adj<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">&quot;&quot;</span>
        <span class="token punctuation">}</span>
        res <span class="token operator">+=</span> <span class="token string">&quot;\n&quot;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre></div><h3 id="测试代码-3"><a href="#测试代码-3" class="header-anchor">#</a> 测试代码</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 测试代码</span>
<span class="token keyword">let</span> graph <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 添加顶点</span>
<span class="token keyword">let</span> myVertexes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;A&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;B&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;C&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;D&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;E&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;F&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;G&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;H&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;I&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> myVertexes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  graph<span class="token punctuation">.</span><span class="token function">addVertex</span><span class="token punctuation">(</span>myVertexes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 添加边</span>
graph<span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token string">&quot;A&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
graph<span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token string">&quot;A&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;C&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
graph<span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token string">&quot;A&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;D&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
graph<span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token string">&quot;C&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;D&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
graph<span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token string">&quot;C&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;G&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
graph<span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token string">&quot;D&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;G&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
graph<span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token string">&quot;D&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;H&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
graph<span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token string">&quot;B&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;E&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
graph<span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token string">&quot;B&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;F&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
graph<span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token string">&quot;E&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;I&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="图的遍历"><a href="#图的遍历" class="header-anchor">#</a> 图的遍历</h2> <p>和其他数据结构一样，需要通过某种算法来遍历图结构中每一个数据。这样可以保证，在我们需要时，通过这种算法来访问某个顶点的数据以及它对应的边。</p> <h3 id="遍历的方式"><a href="#遍历的方式" class="header-anchor">#</a> 遍历的方式</h3> <ul><li><p>图的遍历思想
图的遍历算法的思想在于必须访问每个第一次访问的节点，并且追踪有哪些顶点还没有被访问到。</p></li> <li><p>有两种算法可以对图进行遍历</p> <ul><li>广度优先搜索(Breadth-First Search, 简称 BFS)</li> <li>深度优先搜索(Depth-First Search, 简称 DFS)</li> <li>两种遍历算法，都需要明确指定第一个被访问的顶点。</li></ul></li> <li><p>遍历的注意点</p> <ul><li>完全探索一个顶点要求我们便查看该顶点的每一条边。</li> <li>对于每一条所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。</li> <li>为了保证算法的效率：每个顶点至多访问两次。</li></ul></li> <li><p>两种算法的思想</p> <ul><li>BFS 基于队列，入队列的顶点先被探索。</li> <li>DFS 基于栈，通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问。</li></ul></li> <li><p>为了记录顶点是否被访问过，我们使用三种颜色来反应它们的状态。(或者两种颜色也可以)</p> <ul><li><strong>白色</strong>表示该顶点还没有被访问.</li> <li><strong>灰色</strong>表示该顶点被访问过, 但并未被探索过.</li> <li><strong>黑色</strong>表示该顶点被访问过且被完全探索过.</li> <li>初始化颜色代码</li></ul></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 初始化顶点的颜色</span>
<span class="token function">_initializeColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 白色: 表示该顶点还没有被访问.</span>
    <span class="token comment">// 灰色: 表示该顶点被访问过, 但并未被探索过.</span>
    <span class="token comment">// 黑色: 表示该顶点被访问过且被完全探索过.</span>
    <span class="token keyword">let</span> colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vertexes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        colors<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>vertexes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;white&quot;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> colors
<span class="token punctuation">}</span>
</code></pre></div><h3 id="广度优先搜索-bfs"><a href="#广度优先搜索-bfs" class="header-anchor">#</a> 广度优先搜索(BFS)</h3> <ul><li><p>广度优先搜索算法的思路
广度优先算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是先宽后深的访问顶点。</p></li> <li><p>图解 BFS
<img src="/TechnicalNotes/assets/img/image.3vz7fx7tgvs0.d5ae77a0.png" alt="image"></p></li> <li><p>广度优先搜索的实现</p> <ol><li>创建一个队列 Q</li> <li>将 v 标注为被发现的(灰色), 并将 v 将入队列 Q</li> <li>如果 Q 非空, 执行下面的步骤：
<ul><li>将 v 从 Q 中取出队列</li> <li>将 v 标注为被发现的灰色</li> <li>将 v 所有的未被访问过的邻接点（白色），加入到队列中</li> <li>将 v 标志为黑色</li></ul></li></ol></li> <li><p>广度优先搜索的代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 广度优先搜索</span>
<span class="token function">bfs</span><span class="token punctuation">(</span><span class="token parameter">handle</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1.初始化颜色</span>
    <span class="token keyword">let</span> color <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_initializeColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 2. 创建队列</span>
    <span class="token keyword">let</span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span>
    <span class="token comment">// 3. 将传入的顶点放入队列</span>
    queue<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vertexes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token comment">// 4.依赖队列操作数据   队列不为空时一直持续</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 4.1 拿到队头</span>
        <span class="token keyword">let</span> qVal <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">//  4.2 拿到队头所关联（相连）的点并设置为访问中状态（灰色）</span>
        <span class="token keyword">let</span> qAdj <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>adjList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>qVal<span class="token punctuation">)</span>
        color<span class="token punctuation">[</span>qVal<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;gray&quot;</span>
        <span class="token comment">// 4.3 将队头关联的点添加到队尾</span>
        <span class="token comment">// 这一步是完成bfs的关键，依赖队列的先进先出的特点。</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> qAdj<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> a <span class="token operator">=</span> qAdj<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>color<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">&quot;white&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                color<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;gray&quot;</span>
                queue<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 4.5设置访问完的点为黑色。</span>
        color<span class="token punctuation">[</span>qVal<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;black&quot;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>handle<span class="token punctuation">)</span> <span class="token punctuation">[</span>
            <span class="token function">handle</span><span class="token punctuation">(</span>qVal<span class="token punctuation">)</span>
        <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>测试代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 调用广度优先算法</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
graph<span class="token punctuation">.</span><span class="token function">bfs</span><span class="token punctuation">(</span>graph<span class="token punctuation">.</span>vertexes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  result <span class="token operator">+=</span> v <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// A B C D E F G H I</span>
</code></pre></div></li></ul> <h3 id="深度优先搜索-dfs"><a href="#深度优先搜索-dfs" class="header-anchor">#</a> 深度优先搜索(DFS)</h3> <p>深度优先搜索的思路：</p> <ul><li>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径知道这条路径最后被访问了。</li> <li>接着原路回退并探索下一条路径。</li> <li>图解 DFS
<img src="/TechnicalNotes/assets/img/image.1bjimck65r8g.a4744a08.png" alt="image"></li></ul> <p>深度优先搜索算法的实现：</p> <ul><li><p>广度优先搜索算法我们使用的是队列，这里可以使用栈完成，也可以使用递归。</p></li> <li><p>方便代码书写，我们还是使用递归(递归本质上就是函数栈的调用)</p></li> <li><p>深度优先搜索算法的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 深度优先搜索</span>
<span class="token function">dfs</span><span class="token punctuation">(</span><span class="token parameter">handle</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1.初始化颜色</span>
    <span class="token keyword">let</span> color <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_initializeColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 2. 遍历所有顶点，开始访问</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>vertexes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>color<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>vertexes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">&quot;white&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_dfsVisit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>vertexes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> color<span class="token punctuation">,</span> handle<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// dfs的递归方法  这里直接使用函数的调用栈</span>
<span class="token function">_dfsVisit</span><span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">,</span> color<span class="token punctuation">,</span> handle</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1. 将颜色设置为访问中</span>
    color<span class="token punctuation">[</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;gray&quot;</span>
    <span class="token comment">// 2. 执行相应的回调</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">handle</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 3. 拿与该点相邻的点，对每个点操作</span>
    <span class="token keyword">let</span> adj <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>adjList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> adj<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> w <span class="token operator">=</span> adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        <span class="token comment">// 如果相邻点未未访问状态，开始访问。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>color<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">&quot;white&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_dfsVisit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> color<span class="token punctuation">,</span> handle<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 4. 处理完后设置为访问过点。</span>
    color<span class="token punctuation">[</span>val<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;black&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>测试代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 调用深度优先算法</span>
result <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
graph<span class="token punctuation">.</span><span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  result <span class="token operator">+=</span> v <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出深度优先</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//A B E I F C D G H</span>
</code></pre></div></li> <li><p>递归的代码较难理解一些，这副图来帮助理解过程：
<img src="/TechnicalNotes/assets/img/image.6z6nkgmevxo0.ad2072df.png" alt="image"></p></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新:</span> <span class="time">2022/3/21 10:12:42</span></div></footer> <!----> </main></div> <div class="footer" data-v-34d4abe6><div id="footer-info" data-v-34d4abe6><div class="footer-left" data-v-34d4abe6>
      © 2020-2024
      <!----></div> <div class="footer-right" data-v-34d4abe6>Theme:<a href="https://github.com/JoeyBling/vuepress-theme-yilia-plus" target="_blank">vuepress-theme-yilia-plus</a> by Litten</div></div> <div class="busuanzi" data-v-34d4abe6><span id="busuanzi_container_site_pv" style="display:none">
    本站总访问量
    <span id="busuanzi_value_site_pv"></span>次
    <span class="post-meta-divider">|</span></span> <span id="busuanzi_container_site_uv" style="display:none">
    本站访客数
    <span id="busuanzi_value_site_uv"></span>人
  </span></div></div></main><div class="global-ui"><!----><!----></div></div>
    <script src="/TechnicalNotes/assets/js/app.403c09eb.js" defer></script><script src="/TechnicalNotes/assets/js/3.de768786.js" defer></script><script src="/TechnicalNotes/assets/js/2.0ff0e0af.js" defer></script><script src="/TechnicalNotes/assets/js/13.7842862e.js" defer></script>
  </body>
</html>
